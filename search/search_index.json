{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TrigMem - Trigallez's Memory Management Method","text":"<p>WARNING: Alpha Version - This method is under active development.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>TrigMem is a methodology for organizing Claude Code's memory and context effectively. It provides a systematic approach to deciding what information to store, where to store it, and how to balance the competing concerns of context economy, precision, and reusability.</p>"},{"location":"#the-problem","title":"The Problem","text":"<p>If you use Claude Code, you've probably encountered these pain points:</p> <ul> <li>Where should this go? CLAUDE.md? A Rule? A Skill? A Command?</li> <li>No clear decision criteria: Without guidance, your choices feel arbitrary and inconsistent</li> <li>You mix universal patterns with project-specific paths and kill reusability - your Skills and Rules can't travel between projects</li> <li>Your context window is finite - wrong placement wastes tokens and reduces effectiveness</li> </ul>"},{"location":"#the-solution","title":"The Solution","text":"<p>TrigMem addresses these problems through:</p> <ol> <li>Clear categorization: 6 distinct information types, each with different characteristics and optimal storage locations</li> <li>Multiple storage mechanisms: Each optimized for different trade-offs between persistence, visibility, and token cost</li> <li>Two-phase decision guide: A practical triage \u2192 refinement process for making storage decisions</li> <li>Explicit trade-off framework: Balance Context Economy, Precision, and Reusability intentionally</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to bring order to your Claude Code memory management?</p>"},{"location":"#start-here-understand-the-core-concepts-and-trade-offs-then-follow-the-path-through-the-method","title":"&gt;&gt;Start here&lt;&lt; - Understand the core concepts and trade-offs, then follow the path through the method.","text":""},{"location":"#examples","title":"Examples","text":"<p>See the method in practice with worked examples:</p> <ul> <li>examples/worked-examples.md - Real scenarios showing the decision process</li> </ul>"},{"location":"#license","title":"License","text":"<p>This method is free and open source under the GPL v3 license.</p>"},{"location":"#version","title":"Version","text":"<p>0.1.3 Alpha - 12/02/2026 - adds MkDocs and fix bad anchor link</p>"},{"location":"#previous-releases","title":"Previous releases","text":"<p>0.1.2 Alpha - 12/02/2026 0.1.0 Alpha - 05/02/2026</p>"},{"location":"#author","title":"Author","text":"<p>Arno Trigallez - Copyright\u00a9 February 2026</p>"},{"location":"01-theory/","title":"Section 1: Why It Works \u2014 The Theory","text":"<p>This section introduces the foundational concepts behind TrigMem. Understanding these goals and dimensions will help you make better decisions about where to store information\u2014and more importantly, why those decisions matter.</p> <p>Quick Start Path</p> <p>If you want to jump straight to practical decisions, you can skip to the Two-Phase Decision Guide now and return here when you want deeper understanding. However, reading this section first provides valuable context.</p>"},{"location":"01-theory/#the-three-core-goals","title":"The Three Core Goals","text":"<p>Every storage decision is a trade-off between three competing goals. Understanding these helps you make informed choices\u2014especially when the simpler decision guides don't give a clear answer.</p>"},{"location":"01-theory/#goal-1-context-economy","title":"Goal 1: Context Economy","text":"<p>Minimize token consumption to maximize effectiveness.</p> <p>The AI's context window is a finite, precious resource. Every token loaded\u2014whether from CLAUDE.md, Rules, Skills, or conversation history\u2014is re-sent with every API call. The API is stateless: each message reconstructs the full prompt (system prompt + conversation history + new message).</p> <pre><code>Total Tokens Processed = Tokens \u00d7 Messages in Conversation\n</code></pre> <p>A 500-token CLAUDE.md file is processed: - 500 tokens in a 1-message conversation - 5,000 tokens in a 10-message conversation - 50,000 tokens in a 100-message conversation</p> <p>Implications:</p> <ul> <li>Keep always-loaded content (CLAUDE.md) as small as possible \u2014 it consumes context window space every message</li> <li>Use on-demand loading (Skills, Commands) for detailed instructions</li> <li>Use the pointer pattern: brief references in CLAUDE.md, full content elsewhere</li> <li>Prompt caching mitigates financial cost, but not context window pressure</li> </ul> <p>The prompt caching nuance: Claude Code automatically uses prompt caching. After the first message, cached content (like CLAUDE.md) costs only 10% of the base input price on subsequent reads. So while the tokens are still processed every message, the financial cost is significantly reduced (~90%) for stable, repeated content. However, the tokens still occupy context window space regardless of caching \u2014 which is the more important constraint.</p>"},{"location":"01-theory/#goal-2-precision","title":"Goal 2: Precision","text":"<p>Provide specific, actionable instructions when they're relevant.</p> <p>General advice is often ignored; specific steps are followed. The more precise your instructions, the more reliably Claude will execute them.</p> <p>The Precision Hierarchy:</p> <ol> <li>Vague: \"Write good tests\" (often ignored)</li> <li>General: \"Write unit tests for all functions\" (sometimes followed)</li> <li>Specific: \"Use Jest, mock external dependencies, assert on return values\" (usually followed)</li> <li>Precise: Step-by-step procedure with examples (reliably followed)</li> </ol> <p>Implications:</p> <ul> <li>Skills should contain detailed, actionable procedures</li> <li>Rules should be specific to file types/patterns</li> <li>Don't try to be precise about everything in CLAUDE.md (violates Context Economy)</li> </ul>"},{"location":"01-theory/#goal-3-reusability","title":"Goal 3: Reusability","text":"<p>Write once, use everywhere.</p> <p>The best instructions are portable across projects. This prevents: - Manual copying between projects - \"Config drift\" where copies diverge over time - Redundant work updating the same patterns repeatedly</p> <p>Implications:</p> <ul> <li>Separate universal patterns (portable Skills) from project-specific conventions (Rules/CLAUDE.md)</li> <li>Don't hardcode paths in Skills\u2014use configuration or let the project define them</li> <li>Design Skills to work with any project using the same technology stack</li> </ul>"},{"location":"01-theory/#the-impossible-triangle","title":"The Impossible Triangle","text":"<p>These three goals create tension:</p> <pre><code>                    CONTEXT ECONOMY\n                         /\\\n                        /  \\\n                       /    \\\n                      /      \\\n                     /        \\\n                    /          \\\n                   /____________\\\n            PRECISION          REUSABILITY\n</code></pre> <p>Trade-offs:</p> <ul> <li>Economy vs. Precision: More precise instructions = more tokens</li> <li>Precision vs. Reusability: Project-specific precision kills portability</li> <li>Reusability vs. Economy: Portable skills may load more than needed</li> </ul> <p>The TrigMem Solution:</p> <ul> <li>Use multiple mechanisms with different trade-off profiles</li> <li>CLAUDE.md: Optimizes for Economy (minimal, always-loaded)</li> <li>Skills: Optimizes for Reusability + Precision (detailed, on-demand, portable)</li> <li>Rules: Optimizes for Precision (specific to file patterns)</li> <li>Commands: Optimizes for Precision + Control (user-initiated)</li> </ul>"},{"location":"01-theory/#the-5-dimensions","title":"The 5 Dimensions","text":"<p>Each storage mechanism behaves differently across five key dimensions. Understanding these helps you predict how your storage choice will affect the Three Core Goals.</p>"},{"location":"01-theory/#dimension-1-portability","title":"Dimension 1: Portability","text":"<p>Can this be reused across different projects?</p> Value Meaning Example Universal Works in any project with same tech \"How to write React hooks\" Project-bound Specific to one codebase \"Components are in <code>src/ui/</code>\" Mixed Can be either, depends on content Rules for TypeScript (universal) vs. paths (project-bound) <p>Impact on Goals:</p> <ul> <li>Universal \u2192 High Reusability</li> <li>Project-bound \u2192 Can be more Precise for that project</li> </ul>"},{"location":"01-theory/#dimension-2-loading","title":"Dimension 2: Loading","text":"<p>When does this content enter the context window?</p> Value Meaning Token Impact Always Loaded every conversation High (present every message; financial cost reduced ~90% by prompt caching, but context window impact remains) Pattern-matched Loaded when file patterns match Medium (only when relevant) On-demand Loaded only when explicitly invoked Low (only when needed) <p>Impact on Goals:</p> <ul> <li>Always \u2192 Hurts Economy, but always available</li> <li>On-demand \u2192 Great Economy, but requires invocation</li> </ul>"},{"location":"01-theory/#dimension-3-invocation","title":"Dimension 3: Invocation","text":"<p>Who decides when this gets used?</p> Value Meaning Control Always active Cannot be turned off No control (CLAUDE.md) Automatic Claude decides based on context AI-controlled User-explicit Only runs when user invokes Full user control <p>Impact on Goals:</p> <ul> <li>Automatic \u2192 More convenient, but may load unexpectedly</li> <li>User-explicit \u2192 Predictable, but requires user knowledge</li> </ul> <p>\u26a0\ufe0f Invocation Is Probabilistic, Not Deterministic</p> <p>When a skill's invocation is set to \"Automatic\" (Claude decides), invocation is probabilistic\u2014Claude may or may not invoke the skill depending on prompt context, conversation history, and description matching. A skill that fires reliably in one session may not fire in another. For practical techniques to improve invocation reliability, see Section 7 \u2014 Invocation Reliability.</p>"},{"location":"01-theory/#dimension-4-context-isolation","title":"Dimension 4: Context Isolation","text":"<p>Where does this run?</p> Value Meaning Effect Main context Runs in primary conversation History visible, may clutter Isolated Runs in separate sub-agent Clean handoff, parallel-capable <p>Impact on Goals:</p> <ul> <li>Main context \u2192 Simple, but consumes main context budget</li> <li>Isolated \u2192 Clean, but adds coordination overhead</li> </ul>"},{"location":"01-theory/#dimension-5-composability","title":"Dimension 5: Composability","text":"<p>How well does this combine with other mechanisms?</p> Value Meaning Example High Easily combines with others Skills calling other Skills Medium Some combination possible Rules + CLAUDE.md context Low Standalone operation Commands execute independently <p>Impact on Goals:</p> <ul> <li>High composability \u2192 Flexible, but may increase complexity</li> <li>Low composability \u2192 Simple, but limited integration</li> </ul>"},{"location":"01-theory/#the-mechanism-dimension-matrix","title":"The Mechanism \u00d7 Dimension Matrix","text":"<p>This matrix is your reference tool for understanding how each mechanism behaves.</p> Mechanism Portability Loading Invocation Isolation Composability CLAUDE.md Project-bound Always Always active Main Low Rules Mixed\u00b9 Pattern-matched Automatic Main Medium Skills Universal\u00b2 On-demand Auto or User Main High Commands Universal\u00b2 On-demand User-explicit Main Low Sub-agents Universal\u00b2 On-demand Explicit or Auto Isolated Medium <p>Footnotes:</p> <ol> <li>Rules can be universal (e.g., TypeScript standards) or project-specific (e.g., local paths).    They become project-bound when they contain hardcoded project conventions.</li> <li>Skills, Commands, and Sub-agents are portable by design. Their portability depends on    whether you hardcode project-specific details (which you shouldn't).</li> </ol>"},{"location":"01-theory/#reading-the-matrix","title":"Reading the Matrix","text":"<p>Example 1: \"I need project-specific context available in every conversation\"</p> <ul> <li>Need: Project-bound + Always loaded + Always active</li> <li>\u2192 CLAUDE.md (only mechanism that fits)</li> </ul> <p>Example 2: \"I want reusable how-to knowledge that Claude uses automatically\"</p> <ul> <li>Need: Universal + On-demand + Auto-invoked + High composability</li> <li>\u2192 Skill (best fit across all dimensions)</li> </ul> <p>Example 3: \"I want a deployment workflow only I can trigger\"</p> <ul> <li>Need: Any portability + On-demand + User-explicit</li> <li>\u2192 Command (user-explicit is the key differentiator)</li> </ul> <p>Example 4: \"I need to run a complex task without cluttering my conversation\"</p> <ul> <li>Need: Any + On-demand + Any + Isolated</li> <li>\u2192 Sub-agent (only mechanism with isolation)</li> </ul> <p>Scope Note: Claude Code Hooks</p> <p>Claude Code also provides hooks\u2014lifecycle callbacks (PreToolUse, PostToolUse, SubagentStart, SubagentStop, etc.) that run shell commands at specific points during a conversation. Hooks enable powerful automation: re-injecting context, preventing dangerous commands, auto-formatting files, or validating tool arguments.</p> <p>Hooks are out of scope for TrigMem because they address lifecycle action automation, not what Claude stores and remembers. TrigMem focuses on memory placement\u2014where information lives so Claude can retrieve it. Hooks complement memory management (e.g., a hook could auto-format code after a skill runs) but are not themselves a memory mechanism.</p>"},{"location":"01-theory/#applying-theory-to-decisions","title":"Applying Theory to Decisions","text":""},{"location":"01-theory/#when-the-decision-guide-is-clear","title":"When the Decision Guide Is Clear","text":"<p>For most cases, the Two-Phase Decision Guide gives you a clear answer. Use it first\u2014it encapsulates this theory into practical questions.</p>"},{"location":"01-theory/#when-you-need-theory","title":"When You Need Theory","text":"<p>Use this section when:</p> <ol> <li>Edge cases: The decision guide doesn't clearly point to one destination</li> <li>Use the Matrix to compare trade-offs</li> <li> <p>Optimize for your most important goal (Economy, Precision, or Reusability)</p> </li> <li> <p>Validating decisions: You want to confirm your choice is sound</p> </li> <li>Check the Matrix dimensions</li> <li> <p>Verify the mechanism matches your requirements</p> </li> <li> <p>Designing new patterns: You're creating skills or extending the method</p> </li> <li>Use the Three Core Goals to guide your design</li> <li>Ensure you're not accidentally sacrificing one goal entirely</li> </ol>"},{"location":"01-theory/#trade-off-examples","title":"Trade-off Examples","text":"<p>\"Should this rule be in CLAUDE.md or a Rule file?\"</p> Factor CLAUDE.md Rule Loading Always (costs tokens) Pattern-matched (efficient) Trigger Every conversation Only when matching files edited <p>\u2192 If the rule applies to specific file types, use a Rule. If it's critical project-wide context that Claude needs constantly, use CLAUDE.md (but keep it brief).</p> <p>\"Should this be a Skill or a Command?\"</p> Factor Skill Command Invocation Claude can auto-invoke User must invoke Best for Knowledge Claude should use proactively Actions with side effects <p>\u2192 If Claude should decide when to apply this knowledge, use a Skill. If the user should control when the action runs, use a Command.</p>"},{"location":"01-theory/#summary","title":"Summary","text":""},{"location":"01-theory/#the-three-core-goals_1","title":"The Three Core Goals","text":"<ol> <li>Context Economy: Minimize tokens, maximize effectiveness</li> <li>Precision: Specific, actionable instructions</li> <li>Reusability: Write once, use everywhere</li> </ol>"},{"location":"01-theory/#the-5-dimensions_1","title":"The 5 Dimensions","text":"<ol> <li>Portability: Universal vs. project-bound</li> <li>Loading: Always vs. pattern-matched vs. on-demand</li> <li>Invocation: Always active vs. automatic vs. user-explicit</li> <li>Context Isolation: Main context vs. isolated</li> <li>Composability: How well it combines with other mechanisms</li> </ol>"},{"location":"01-theory/#the-key-insight","title":"The Key Insight","text":"<p>No single mechanism optimizes all three goals. TrigMem uses multiple mechanisms, each with different trade-off profiles, to let you choose the right tool for each type of information.</p> <p>For practical decisions, use the Two-Phase Decision Guide. Return here when you need to understand why a decision is correct or handle edge cases.</p> <p>Next: Section 2 - What You're Storing</p>"},{"location":"02-what-youre-storing/","title":"Section 2: What You're Storing","text":"<p>Before choosing where to put information, you must first identify what it is. Most confusion comes from mixing different types of information together\u2014for example, embedding universal architectural patterns alongside project-specific folder paths. This section helps you categorize your content so later sections can point you to the right destination.</p>"},{"location":"02-what-youre-storing/#the-6-information-categories","title":"The 6 Information Categories","text":"<p>Every piece of information you want to store falls into one of six distinct categories. Understanding these categories is the foundation for making the right storage decision.</p> # Category Character Typical Destination 1 Project Identity Unique, rarely changes CLAUDE.md 2 Codebase Structure Unique, helps navigation CLAUDE.md / Rules 3 Operational Commands Procedural, project-specific Commands 4 Reusable Patterns Universal, portable Skills 5 Architectural Guidance Project-specific application Rules / CLAUDE.md 6 Iterative Corrections Reactive, accumulated Rules / CLAUDE.md"},{"location":"02-what-youre-storing/#category-1-project-identity","title":"Category 1: Project Identity","text":""},{"location":"02-what-youre-storing/#description","title":"Description","text":"<p>High-level context about what the project is and its core technology stack. This is the \"business card\" of your project\u2014information that rarely changes and provides essential orientation for any AI assistant.</p>"},{"location":"02-what-youre-storing/#character","title":"Character","text":"<p>Unique per project. Rarely changes once established.</p>"},{"location":"02-what-youre-storing/#examples","title":"Examples","text":"<p>Example 1: E-commerce Platform <pre><code>This is ShopFlow, a B2B e-commerce platform for wholesale distributors.\nBuilt with: Next.js 14, TypeScript, Prisma, PostgreSQL, Stripe.\n</code></pre></p> <p>Example 2: CLI Tool <pre><code>TrigMem is a methodology and skill collection for organizing Claude Code memory.\nPure Markdown deliverables, no runtime dependencies.\n</code></pre></p> <p>Example 3: Mobile App Backend <pre><code>PetTracker API - Backend service for pet health monitoring mobile app.\nStack: Go, gRPC, Redis, MongoDB, deployed on GCP Cloud Run.\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints","title":"Destination Hints","text":"<p>\u2192 Almost always goes in CLAUDE.md (always-loaded, identity-focused).</p>"},{"location":"02-what-youre-storing/#category-2-codebase-structure","title":"Category 2: Codebase Structure","text":""},{"location":"02-what-youre-storing/#description_1","title":"Description","text":"<p>Knowledge of where things live in this specific codebase. This helps Claude navigate your project without having to re-discover the structure each time.</p>"},{"location":"02-what-youre-storing/#character_1","title":"Character","text":"<p>Unique per project. Helps Claude navigate efficiently.</p>"},{"location":"02-what-youre-storing/#examples_1","title":"Examples","text":"<p>Example 1: Monorepo Layout <pre><code>packages/\n\u251c\u2500\u2500 web/          # Next.js frontend\n\u251c\u2500\u2500 api/          # Express backend\n\u251c\u2500\u2500 shared/       # Shared types and utilities\n\u2514\u2500\u2500 mobile/       # React Native app\n</code></pre></p> <p>Example 2: Domain-Driven Design Layout <pre><code>src/\n\u251c\u2500\u2500 domain/       # Business logic, entities\n\u251c\u2500\u2500 application/  # Use cases, services\n\u251c\u2500\u2500 infrastructure/  # Database, external APIs\n\u2514\u2500\u2500 presentation/ # Controllers, views\n</code></pre></p> <p>Example 3: Simple Project <pre><code>Components in src/components/\nAPI routes in src/pages/api/\nDatabase migrations in prisma/migrations/\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints_1","title":"Destination Hints","text":"<p>\u2192 CLAUDE.md for high-level map (always needed)</p> <p>\u2192 Rules for directory-specific conventions (triggered when working in those areas)</p>"},{"location":"02-what-youre-storing/#category-3-operational-commands","title":"Category 3: Operational Commands","text":""},{"location":"02-what-youre-storing/#description_2","title":"Description","text":"<p>Instructions on how to build, test, deploy, and run the project. These are the \"verbs\"\u2014actions that execute specific workflows.</p>"},{"location":"02-what-youre-storing/#character_2","title":"Character","text":"<p>Procedural but project-specific. Step-by-step procedures with side effects.</p>"},{"location":"02-what-youre-storing/#examples_2","title":"Examples","text":"<p>Example 1: Development Workflow <pre><code>To start development:\n1. pnpm install\n2. docker compose up -d\n3. pnpm run dev\n</code></pre></p> <p>Example 2: Deployment Process <pre><code>Deploy to staging:\n1. Run tests: pnpm test\n2. Build: pnpm build\n3. Deploy: ./scripts/deploy-staging.sh\n4. Smoke test: curl https://staging.example.com/health\n</code></pre></p> <p>Example 3: Database Operations <pre><code>Reset database:\n1. docker compose down -v\n2. docker compose up -d postgres\n3. pnpm prisma migrate reset --force\n4. pnpm prisma db seed\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints_2","title":"Destination Hints","text":"<p>\u2192 Commands for user-initiated workflows (explicit invocation)</p> <p>\u2192 CLAUDE.md for frequently-needed quick commands (just the essential ones)</p>"},{"location":"02-what-youre-storing/#category-4-reusable-patterns","title":"Category 4: Reusable Patterns","text":""},{"location":"02-what-youre-storing/#description_3","title":"Description","text":"<p>Universal \"how-to\" knowledge that applies across many projects using the same technology or methodology. This is the concept\u2014the pattern itself, independent of any specific implementation.</p>"},{"location":"02-what-youre-storing/#character_3","title":"Character","text":"<p>Universal. Portable across projects using the same stack.</p>"},{"location":"02-what-youre-storing/#examples_3","title":"Examples","text":"<p>Example 1: Hexagonal Architecture Pattern <pre><code>Hexagonal Architecture separates business logic from infrastructure:\n- Domain layer contains pure business rules\n- Ports define interfaces the domain needs\n- Adapters implement ports for specific technologies\n- Dependencies point inward (adapters depend on ports, not vice versa)\n</code></pre></p> <p>Example 2: React Custom Hook Pattern <pre><code>Custom hooks encapsulate reusable stateful logic:\n- Name starts with \"use\"\n- Can call other hooks\n- Returns values and functions the component needs\n- Follows the Rules of Hooks\n</code></pre></p> <p>Example 3: Test-Driven Development Pattern <pre><code>TDD cycle:\n1. Write a failing test for the new behavior\n2. Write minimal code to make the test pass\n3. Refactor while keeping tests green\n4. Repeat\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints_3","title":"Destination Hints","text":"<p>\u2192 Skills (reusable, on-demand, can be shared across projects)</p>"},{"location":"02-what-youre-storing/#category-5-architectural-guidance","title":"Category 5: Architectural Guidance","text":""},{"location":"02-what-youre-storing/#description_4","title":"Description","text":"<p>How a universal pattern is implemented specifically in this project. This is the convention\u2014 the project-specific decisions about file locations, naming, and structure.</p>"},{"location":"02-what-youre-storing/#character_4","title":"Character","text":"<p>Project-specific application of universal patterns.</p>"},{"location":"02-what-youre-storing/#examples_4","title":"Examples","text":"<p>Example 1: Hexagonal Implementation (This Project) <pre><code>In this project, Hexagonal Architecture is implemented as:\n- Domain: src/domain/\n- Ports: src/domain/ports/\n- Adapters: src/infrastructure/adapters/\n- Use cases: src/application/\n</code></pre></p> <p>Example 2: Component Conventions (This Project) <pre><code>Our component file structure:\n- ComponentName/\n  \u251c\u2500\u2500 index.tsx         # Main component\n  \u251c\u2500\u2500 ComponentName.test.tsx\n  \u251c\u2500\u2500 ComponentName.styles.ts\n  \u2514\u2500\u2500 types.ts\n</code></pre></p> <p>Example 3: API Patterns (This Project) <pre><code>API endpoint conventions:\n- Routes: src/pages/api/v1/{resource}/[id].ts\n- Handlers: src/services/{resource}Service.ts\n- Validators: src/validators/{resource}Schema.ts\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints_4","title":"Destination Hints","text":"<p>\u2192 Rules for directory-specific conventions (load when relevant)</p> <p>\u2192 CLAUDE.md for project-wide conventions (if brief and always needed)</p> <p>\u2192 Linked file for detailed conventions (e.g., <code>See docs/architecture.md</code> in CLAUDE.md)</p>"},{"location":"02-what-youre-storing/#category-6-iterative-corrections","title":"Category 6: Iterative Corrections","text":""},{"location":"02-what-youre-storing/#description_5","title":"Description","text":"<p>\"Remember this\" fixes accumulated when Claude makes repeated mistakes. These are reactive learnings that prevent the same errors from recurring.</p>"},{"location":"02-what-youre-storing/#character_5","title":"Character","text":"<p>Reactive. Accumulated learnings from experience.</p>"},{"location":"02-what-youre-storing/#examples_5","title":"Examples","text":"<p>Example 1: Language/Framework Quirks <pre><code>Don't use 'any' in TypeScript - use 'unknown' and narrow the type.\n</code></pre></p> <p>Example 2: Project-Specific Gotchas <pre><code>The 'user' table has a trigger - never INSERT directly, use the create_user() function.\n</code></pre></p> <p>Example 3: Tool-Specific Behavior <pre><code>When using pnpm, always run 'pnpm install' after switching branches.\n</code></pre></p>"},{"location":"02-what-youre-storing/#destination-hints_5","title":"Destination Hints","text":"<p>\u2192 Rules for file-type-specific corrections (e.g., TypeScript rules for <code>.ts</code> files)</p> <p>\u2192 CLAUDE.md for project-wide corrections (if critical and always needed)</p>"},{"location":"02-what-youre-storing/#the-critical-distinction-category-4-vs-category-5","title":"The Critical Distinction: Category 4 vs. Category 5","text":"<p>The most important separation to understand is between Reusable Patterns (Cat 4) and Architectural Guidance (Cat 5).</p>"},{"location":"02-what-youre-storing/#the-problem","title":"The Problem","text":"<p>When you mix these categories, you kill reusability:</p> <pre><code># BAD: Mixed Categories\nWhen implementing Hexagonal Architecture:\n- Put domain in src/domain/           \u2190 This is Cat 5 (project-specific)\n- Put ports in src/ports/             \u2190 This is Cat 5 (project-specific)\n- Domain should have no dependencies  \u2190 This is Cat 4 (universal)\n</code></pre> <p>If you share this \"skill\" with another project, those paths won't work.</p>"},{"location":"02-what-youre-storing/#the-solution","title":"The Solution","text":"<p>Separate the Universal How (Cat 4) from the Local Where (Cat 5):</p> <pre><code># GOOD: Category 4 (Skill - Portable)\nHexagonal Architecture separates business logic from infrastructure:\n- Domain layer contains pure business rules\n- Ports define interfaces the domain needs\n- Adapters implement ports\n</code></pre> <pre><code># GOOD: Category 5 (Rule - Project-Specific)\nOur Hexagonal implementation:\n- Domain: src/domain/\n- Ports: src/domain/ports/\n- Adapters: src/infrastructure/\n</code></pre> <p>Now the skill is reusable, and the conventions are project-local.</p> <p>Experimental Alternative: Configurable Skills offer a way to get the best of both worlds\u2014keeping universal patterns portable while allowing project-specific configuration within the same skill file.</p>"},{"location":"02-what-youre-storing/#self-assessment-what-category-is-my-content","title":"Self-Assessment: What Category Is My Content?","text":"<p>Use these questions to identify what you're storing:</p>"},{"location":"02-what-youre-storing/#question-1-is-this-about-what-my-project-is","title":"Question 1: Is this about WHAT my project is?","text":"<p>Yes \u2192 Category 1: Project Identity</p> <ul> <li>Project name, purpose, tech stack</li> <li>Rarely changes</li> <li>Anyone new needs to know this immediately</li> </ul>"},{"location":"02-what-youre-storing/#question-2-is-this-about-where-things-are-in-my-codebase","title":"Question 2: Is this about WHERE things are in my codebase?","text":"<p>Yes \u2192 Category 2: Codebase Structure</p> <ul> <li>Directory structure, file locations</li> <li>Project-specific navigation</li> <li>Helps Claude find things</li> </ul>"},{"location":"02-what-youre-storing/#question-3-is-this-about-how-to-do-something-actionworkflow","title":"Question 3: Is this about HOW TO DO something (action/workflow)?","text":"<p>Yes, and it has side effects \u2192 Category 3: Operational Commands</p> <ul> <li>Build, test, deploy, run</li> <li>Step-by-step procedures</li> <li>User initiates these actions</li> </ul> <p>Yes, and it's universal knowledge \u2192 Category 4: Reusable Patterns</p> <ul> <li>Could apply to any project with this tech stack</li> <li>The concept, not the convention</li> <li>\"How to implement X pattern\"</li> </ul> <p>Yes, and it's how we specifically do it here \u2192 Category 5: Architectural Guidance</p> <ul> <li>Project-specific implementation details</li> <li>File paths, naming conventions, local decisions</li> <li>\"In THIS project, we put X in Y\"</li> </ul>"},{"location":"02-what-youre-storing/#question-4-is-this-a-correction-for-a-repeated-mistake","title":"Question 4: Is this a correction for a repeated mistake?","text":"<p>Yes \u2192 Category 6: Iterative Corrections</p> <ul> <li>\"Don't do X\" or \"Always do Y\"</li> <li>Accumulated from experience</li> <li>Prevents recurring errors</li> </ul>"},{"location":"02-what-youre-storing/#decision-flow-ambiguous-cases","title":"Decision Flow: Ambiguous Cases","text":"<p>Some information could fit multiple categories. Here's how to resolve ambiguity:</p>"},{"location":"02-what-youre-storing/#we-use-typescript-with-strict-mode","title":"\"We use TypeScript with strict mode\"","text":"<ul> <li>Identity (Cat 1) if it's part of defining the project</li> <li>Correction (Cat 6) if it's reminding Claude of a standard</li> </ul> <p>\u2192 Resolution: Put core tech stack in Cat 1 (CLAUDE.md). Add specific compiler rules to Cat 6 (Rules for <code>.ts</code> files) only if Claude keeps getting it wrong.</p>"},{"location":"02-what-youre-storing/#run-tests-with-pnpm-test","title":"\"Run tests with <code>pnpm test</code>\"","text":"<ul> <li>Operational Command (Cat 3) if it's a workflow step</li> <li>Identity (Cat 1) if it's just stating the test runner</li> </ul> <p>\u2192 Resolution: Simple command mentions go in Cat 1 (CLAUDE.md: \"Tests: <code>pnpm test</code>\"). Full test workflows go in Cat 3 (Command with pre/post steps).</p>"},{"location":"02-what-youre-storing/#components-should-have-a-single-responsibility","title":"\"Components should have a single responsibility\"","text":"<ul> <li>Reusable Pattern (Cat 4) if it's teaching a principle</li> <li>Correction (Cat 6) if Claude keeps making bloated components</li> </ul> <p>\u2192 Resolution: If Claude already knows this, it's a Correction (triggered when relevant). If you're teaching a specific methodology, it's a Pattern (Skill).</p>"},{"location":"02-what-youre-storing/#quick-reference","title":"Quick Reference","text":"Question Yes Points To Is this about what my project is? Cat 1: Project Identity Is this about where things are? Cat 2: Codebase Structure Is this a command/action with side effects? Cat 3: Operational Commands Is this universal how-to knowledge? Cat 4: Reusable Patterns Is this our specific implementation? Cat 5: Architectural Guidance Is this a don't do that again fix? Cat 6: Iterative Corrections"},{"location":"02-what-youre-storing/#summary","title":"Summary","text":"<p>Understanding these six categories is essential before using the Two-Phase Decision Guide:</p> <ol> <li>Project Identity \u2192 What is this project? (CLAUDE.md)</li> <li>Codebase Structure \u2192 Where is everything? (CLAUDE.md / Rules)</li> <li>Operational Commands \u2192 How do I run/build/deploy? (Commands)</li> <li>Reusable Patterns \u2192 Universal how-to knowledge (Skills)</li> <li>Architectural Guidance \u2192 Our specific implementation (Rules)</li> <li>Iterative Corrections \u2192 Don't make that mistake again (Rules)</li> </ol> <p>The key insight: Separate the Universal How (Cat 4) from the Local Where (Cat 5) to maximize reusability while keeping project-specific conventions where they belong.</p> <p>Previous: Section 1 - Why It Works: The Theory Next: Section 3 - The Storage Options</p>"},{"location":"03-storage-options/","title":"Section 3: The Storage Options","text":"<p>Already familiar with Claude Code storage?</p> <p>If you already know how CLAUDE.md, Rules, Skills, Commands, and Sub-agents work, you can skip to the Two-Phase Decision Guide. This section is a reference\u2014come back when you need specifics.</p> <p>This section provides a complete reference of all memory mechanisms available in Claude Code. With the theory and categories from Sections 1-2, you can now understand why each mechanism is designed the way it is.</p>"},{"location":"03-storage-options/#overview","title":"Overview","text":"<p>Claude Code provides five distinct memory mechanisms, each designed for specific use cases. The key to effective AI memory management is understanding when to use each one.</p> Mechanism Primary Purpose When Loaded CLAUDE.md Project identity &amp; essential context Always (every conversation) Rules Pattern-triggered behavioral guidance When file patterns match Skills Reusable procedures &amp; knowledge On-demand (user or Claude) Commands User-controlled workflows Explicit user invocation Sub-agents Isolated, focused task execution When spawned for specific tasks"},{"location":"03-storage-options/#1-claudemd","title":"1. CLAUDE.md","text":""},{"location":"03-storage-options/#purpose","title":"Purpose","text":"<p>The CLAUDE.md file serves as the project identity card. It provides essential context that Claude needs in every conversation about your project.</p>"},{"location":"03-storage-options/#when-loaded","title":"When Loaded","text":"<p>Always \u2014 included in the system prompt for every message in a conversation. The API is stateless, so CLAUDE.md is re-sent with each request. Prompt caching reduces financial cost but not context pressure (see Section 1 \u2014 Context Economy).</p>"},{"location":"03-storage-options/#file-location","title":"File Location","text":"<pre><code>project-root/\n\u2514\u2500\u2500 CLAUDE.md\n</code></pre> <p>Claude Code also checks for CLAUDE.md files in parent directories, creating a hierarchy of context.</p>"},{"location":"03-storage-options/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Always in context: No invocation needed</li> <li>Project-bound: Tied to this specific project</li> <li>Token-sensitive: Keep it concise (target 100-200 tokens)</li> <li>Identity-focused: Who/what/where, not detailed how-to</li> </ul>"},{"location":"03-storage-options/#best-for","title":"Best For","text":"<ul> <li>Project name and brief description</li> <li>Tech stack summary (e.g., \"TypeScript + React + PostgreSQL\")</li> <li>Key directory pointers (e.g., \"Source code in <code>src/</code>, tests in <code>tests/</code>\")</li> <li>Critical constraints (e.g., \"Never modify <code>legacy/</code> folder\")</li> <li>Links to detailed documentation (pointer pattern)</li> </ul>"},{"location":"03-storage-options/#anti-patterns","title":"Anti-Patterns","text":"<ul> <li>Full architecture documentation</li> <li>Complete coding style guides</li> <li>Long lists of rules</li> <li>Step-by-step procedures</li> </ul>"},{"location":"03-storage-options/#2-rules","title":"2. Rules","text":""},{"location":"03-storage-options/#purpose_1","title":"Purpose","text":"<p>Rules provide automatic behavioral guidance that activates when Claude is working with specific file types or patterns. Think of them as \"if working on X, remember Y.\"</p>"},{"location":"03-storage-options/#when-loaded_1","title":"When Loaded","text":"<p>Pattern-triggered - loaded automatically when Claude is working with files that match the rule's glob pattern.</p>"},{"location":"03-storage-options/#file-location_1","title":"File Location","text":"<pre><code>project-root/\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 rules/\n        \u251c\u2500\u2500 typescript.md      # Triggered by *.ts files\n        \u251c\u2500\u2500 tests.md           # Triggered by *.test.* files\n        \u2514\u2500\u2500 api-routes.md      # Triggered by src/api/**\n</code></pre>"},{"location":"03-storage-options/#rule-file-format","title":"Rule File Format","text":"<pre><code>---\nglobs: [\"*.ts\", \"*.tsx\"]\n---\n\n# TypeScript Rules\n\nWhen working with TypeScript files:\n- Use strict mode\n- Prefer interfaces over types for object shapes\n- ...\n</code></pre>"},{"location":"03-storage-options/#key-characteristics_1","title":"Key Characteristics","text":"<ul> <li>Automatic activation: No user action needed</li> <li>Pattern-scoped: Only loads when relevant files are accessed</li> <li>Contextual: Guidance appears when it's most relevant</li> <li>Composable: Multiple rules can apply simultaneously</li> </ul>"},{"location":"03-storage-options/#best-for_1","title":"Best For","text":"<ul> <li>File-type-specific coding standards</li> <li>Directory-specific conventions</li> <li>Pattern-based reminders</li> <li>Contextual warnings</li> </ul>"},{"location":"03-storage-options/#considerations","title":"Considerations","text":"<ul> <li>Rules add to context when triggered\u2014keep them focused</li> <li>Overlapping patterns can cause multiple rules to load</li> <li>Good for \"always do this when working on X\" guidance</li> </ul> <p>\u26a0\ufe0f Warning: Broad Patterns</p> <p>Rules with broad globs (e.g., <code>**/*</code>, <code>*</code>, or no globs at all) load on nearly every file access, providing no token savings over CLAUDE.md. Use specific patterns like <code>*.ts</code> or <code>src/api/**</code>.</p> Pattern Effect <code>*.ts</code> Loads only for TypeScript files \u2713 <code>src/api/**</code> Loads only in API directory \u2713 <code>**/*</code> Loads for all files \u2717 (no savings) (no globs) May load frequently \u2717"},{"location":"03-storage-options/#3-skills","title":"3. Skills","text":""},{"location":"03-storage-options/#purpose_2","title":"Purpose","text":"<p>Skills are reusable knowledge and procedures that Claude can invoke when needed. They encapsulate expertise that applies across many situations.</p>"},{"location":"03-storage-options/#when-loaded_2","title":"When Loaded","text":"<p>On-demand - loaded when: - User explicitly invokes with <code>/skill-name</code> - Claude determines the skill is relevant (auto-invocation)</p>"},{"location":"03-storage-options/#file-location_2","title":"File Location","text":"<pre><code>project-root/\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 skills/\n        \u2514\u2500\u2500 skill-name/\n            \u2514\u2500\u2500 SKILL.md\n</code></pre>"},{"location":"03-storage-options/#skill-file-format","title":"Skill File Format","text":"<pre><code>---\nname: skill-name\ndescription: |\n  What this skill does.\n  Use when [specific triggers], [scenarios], or when user asks [questions].\nallowed-tools: Read, Grep, Glob\n---\n\n# Skill Name\n\n# Purpose\nBrief description of what this skill accomplishes.\n\n# Instructions\nStep-by-step instructions Claude follows.\n\n# Configuration (if configurable)\nYAML config block with project-specific values.\n</code></pre>"},{"location":"03-storage-options/#key-characteristics_2","title":"Key Characteristics","text":"<ul> <li>Lazy loading: Only loaded when invoked</li> <li>Reusable: Can be universal (portable) or project-specific</li> <li>Self-documenting: Description tells Claude when to use it</li> <li>Composable: Skills can reference other skills</li> </ul>"},{"location":"03-storage-options/#stack-scoped-portability","title":"Stack-Scoped Portability","text":"<p>Skills are portable within a technology stack. A React skill works on any React project; a Python testing skill works on any Python project. A well-crafted skill becomes a reusable asset across every project in that stack\u2014write once, use in all matching projects.</p>"},{"location":"03-storage-options/#invocation-control","title":"Invocation Control","text":"Frontmatter User invokes Claude invokes (default) Yes Yes <code>disable-model-invocation: true</code> Yes No <code>user-invocable: false</code> No Yes <p>Note: Skill Invocation Is Probabilistic</p> <p>When Claude auto-invokes a skill, invocation is probabilistic\u2014it depends on how well the skill's <code>description</code> matches the current prompt context. A skill may fire reliably in one conversation but not in another. To improve reliability:</p> <ul> <li>Add explicit directives in CLAUDE.md (e.g., \"Always use the <code>/code-review</code> skill when   reviewing pull requests\")</li> <li>Use fully qualified skill names in prompts (e.g., <code>/project-name:skill-name</code>)</li> <li>Reference exact skill paths in your prompt (e.g., \"Use the skill at   <code>.claude/skills/error-handling/SKILL.md</code>\")</li> </ul> <p>For a comprehensive treatment, see Section 7 \u2014 Invocation Reliability.</p>"},{"location":"03-storage-options/#best-for_2","title":"Best For","text":"<ul> <li>How-to procedures (e.g., \"how to implement X pattern\")</li> <li>Reusable methodologies (e.g., code review checklists)</li> <li>Domain expertise (e.g., security best practices)</li> <li>Complex multi-step workflows</li> </ul>"},{"location":"03-storage-options/#4-commands","title":"4. Commands","text":""},{"location":"03-storage-options/#purpose_3","title":"Purpose","text":"<p>Commands are user-controlled workflows with explicit triggers. They represent actions the user consciously initiates.</p>"},{"location":"03-storage-options/#when-loaded_3","title":"When Loaded","text":"<p>Explicit invocation only - loaded when user types <code>/command-name</code>.</p>"},{"location":"03-storage-options/#file-location_3","title":"File Location","text":"<pre><code>project-root/\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 commands/\n        \u2514\u2500\u2500 command-name.md\n</code></pre>"},{"location":"03-storage-options/#command-file-format","title":"Command File Format","text":"<pre><code># Command Name\n\nBrief description of what this command does.\n\n## Instructions\n\nSteps Claude follows when this command is invoked.\n</code></pre>"},{"location":"03-storage-options/#key-characteristics_3","title":"Key Characteristics","text":"<ul> <li>User-initiated: Never auto-invoked by Claude</li> <li>Action-oriented: Typically has side effects (creates files, runs commands)</li> <li>Explicit: User knows exactly what they're triggering</li> <li>Visible: Always appears in the <code>/</code> menu</li> </ul>"},{"location":"03-storage-options/#best-for_3","title":"Best For","text":"<ul> <li>Deployment workflows</li> <li>Code generation templates</li> <li>Project-specific automation</li> <li>Actions with significant side effects</li> </ul>"},{"location":"03-storage-options/#5-sub-agents","title":"5. Sub-agents","text":""},{"location":"03-storage-options/#purpose_4","title":"Purpose","text":"<p>Sub-agents provide isolated execution contexts for focused, complex tasks. They run in a separate context with their own conversation history.</p>"},{"location":"03-storage-options/#when-loaded_4","title":"When Loaded","text":"<p>When spawned - created on-demand for specific tasks, typically via the Task tool or explicit agent configuration.</p>"},{"location":"03-storage-options/#file-location_4","title":"File Location","text":"<pre><code>project-root/\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 agents/\n        \u2514\u2500\u2500 agent-name.md\n</code></pre>"},{"location":"03-storage-options/#key-characteristics_4","title":"Key Characteristics","text":"<ul> <li>Context isolation: Separate conversation history</li> <li>Focused: Single responsibility per agent</li> <li>Parallel-capable: Multiple agents can run simultaneously</li> <li>Clean handoff: Results returned to parent context</li> </ul> <p>\u26a0\ufe0f Sub-agent Context Isolation: What Is NOT Inherited</p> <p>Sub-agents run in an isolated context that does not inherit from the parent conversation:</p> <ul> <li>CLAUDE.md is NOT loaded \u2014 sub-agents receive only their own system prompt plus basic   environment details (working directory, platform). They do not see the project's CLAUDE.md.</li> <li>Skills are NOT inherited \u2014 the parent conversation's skill registry is not available   to the sub-agent.</li> <li>Rules are NOT inherited \u2014 pattern-matched rules from the parent context do not carry over.</li> </ul> <p>Mechanisms for passing context to sub-agents:</p> <ul> <li>Custom sub-agents (<code>.claude/agents/</code>): Use the <code>skills:</code> frontmatter field to explicitly   preload skills. This injects the full skill content into the sub-agent's context at startup.</li> <li>Ad-hoc Task tool sub-agents (Explore, Plan, general-purpose): Have no <code>skills:</code> mechanism.   You must pass relevant content directly in the prompt text when spawning the sub-agent.</li> </ul> <p>See the official sub-agent documentation for details.</p>"},{"location":"03-storage-options/#best-for_4","title":"Best For","text":"<ul> <li>Large refactoring tasks</li> <li>Parallel independent work streams</li> <li>Tasks requiring clean slate context</li> <li>Complex operations benefiting from isolation</li> </ul>"},{"location":"03-storage-options/#skills-and-commands-understanding-the-merger","title":"Skills and Commands: Understanding the Merger","text":"<p>Recent Claude Code updates have unified the skill and command systems. Here's what you need to know:</p>"},{"location":"03-storage-options/#current-behavior","title":"Current Behavior","text":"<ul> <li>Both live in <code>.claude/</code>: Skills in <code>skills/</code>, commands in <code>commands/</code></li> <li>Both use frontmatter: Same YAML configuration options</li> <li>Invocation differs: Commands are user-only; skills can be auto-invoked</li> </ul>"},{"location":"03-storage-options/#key-distinction","title":"Key Distinction","text":"<p>The primary difference is invocation control:</p> Type Auto-invocable by Claude User invocable Skill (default) Yes Yes Skill (<code>disable-model-invocation: true</code>) No Yes Command No Yes"},{"location":"03-storage-options/#practical-guidance","title":"Practical Guidance","text":"<ul> <li>Use Commands when: The action has side effects and should only run when user explicitly wants it</li> <li>Use Skills when: The knowledge/procedure might be useful and Claude should be able to invoke it</li> <li>Use <code>disable-model-invocation: true</code>: When you want skill organization but command-like behavior</li> </ul>"},{"location":"03-storage-options/#priority-and-precedence","title":"Priority and Precedence","text":"<p>When multiple mechanisms provide conflicting guidance, Claude Code follows this general precedence:</p>"},{"location":"03-storage-options/#loading-priority","title":"Loading Priority","text":"<ol> <li>CLAUDE.md - Always loaded first, establishes baseline context</li> <li>Rules - Loaded when file patterns match, layer on top of CLAUDE.md</li> <li>Skills/Commands - Loaded on invocation, most specific context</li> </ol>"},{"location":"03-storage-options/#conflict-resolution","title":"Conflict Resolution","text":"<ul> <li>Later context generally wins: Skills invoked during a task can override earlier guidance</li> <li>Specificity matters: More specific guidance (skill for exact task) typically takes precedence</li> <li>Explicit &gt; implicit: User-invoked commands/skills override auto-loaded rules</li> </ul>"},{"location":"03-storage-options/#best-practice","title":"Best Practice","text":"<p>Avoid conflicts by design: - CLAUDE.md: Identity and pointers (what/where) - Rules: File-type conventions (how for specific files) - Skills: Procedures and methods (how to do X) - Commands: User actions (do X now)</p> <p>When mechanisms overlap, the most recently loaded, most specific guidance typically prevails.</p>"},{"location":"03-storage-options/#quick-reference-table","title":"Quick Reference Table","text":"Aspect CLAUDE.md Rules Skills Commands Sub-agents Location Root <code>.claude/rules/</code> <code>.claude/skills/</code> <code>.claude/commands/</code> <code>.claude/agents/</code> Loading Always Pattern-match On-demand User-invoke When spawned Scope Project File patterns Universal/Project Project Task-specific Context Cost Every message When triggered When invoked When invoked Isolated Auto-invoke N/A Yes (by pattern) Yes (optional) No No Best For Identity Conventions Procedures Actions Isolation"},{"location":"03-storage-options/#official-documentation","title":"Official Documentation","text":"<p>For authoritative details on each mechanism, see the official Claude Code documentation:</p> Mechanism Official Docs CLAUDE.md Memory Skills Extend Claude with skills Sub-agents Create custom subagents Overview Extend Claude Code <p>Note: Skills and Commands have been merged in recent Claude Code versions. See the Skills documentation for current behavior.</p>"},{"location":"03-storage-options/#summary","title":"Summary","text":"<p>Choosing the right mechanism depends on:</p> <ol> <li>When should this be available? (always vs. on-demand vs. pattern-triggered)</li> <li>Who should trigger it? (automatic vs. user-controlled)</li> <li>Is context isolation needed? (main context vs. sub-agent)</li> <li>Is it reusable across projects? (portable vs. project-specific)</li> </ol> <p>Now that you understand the mechanisms, the next section brings it all together with a practical decision framework.</p> <p>Previous: Section 2 - What You're Storing Next: Section 4 - Two-Phase Decision Guide</p>"},{"location":"04-two-phase-decision-guide/","title":"Section 4: The Two-Phase Decision Guide","text":"<p>This is the practical heart of TrigMem\u2014where theory meets action. The two-phase approach lets you make quick, reliable decisions\u2014most common cases can be resolved in under 30 seconds. If you understand the theory (Section 1) and categories (Section 2), this guide shows you how to apply them.</p>"},{"location":"04-two-phase-decision-guide/#how-this-guide-works","title":"How This Guide Works","text":"<p>Phase 1: Triage \u2014 Answer 4 quick questions to identify your destination.</p> <p>Phase 2: Refinement \u2014 Apply destination-specific guidance to finalize placement.</p> <p>Note for AI Agents: This two-phase approach is designed for human learning. If you're an AI reading this, you can often decide directly by analyzing the content against the 6 information categories (Section 2) and the mechanism characteristics (Section 3). The phased approach helps humans build intuition.</p>"},{"location":"04-two-phase-decision-guide/#phase-1-the-triage-questions","title":"Phase 1: The Triage Questions","text":"<p>Answer these questions in order. Stop at the first \"Yes.\"</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           PHASE 1: TRIAGE                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                             \u2502\n\u2502  Q1: Is this a USER-TRIGGERED ACTION with side effects?                    \u2502\n\u2502      (build, deploy, generate, run tests)                                   \u2502\n\u2502      YES \u2192 COMMAND                                                          \u2502\n\u2502                                                                             \u2502\n\u2502  Q2: Is this UNIVERSAL HOW-TO knowledge portable across projects?           \u2502\n\u2502      (patterns, methodologies, procedures)                                  \u2502\n\u2502      YES \u2192 SKILL                                                            \u2502\n\u2502                                                                             \u2502\n\u2502  Q3: Does this need CONTEXT ISOLATION or parallel execution?                \u2502\n\u2502      (large refactoring, independent workstreams)                           \u2502\n\u2502      YES \u2192 SUB-AGENT                                                        \u2502\n\u2502                                                                             \u2502\n\u2502  Q4: Is this ALWAYS-NEEDED project context or corrections?                  \u2502\n\u2502      (identity, structure, rules, fixes)                                    \u2502\n\u2502      YES \u2192 CLAUDE.md / RULES                                                \u2502\n\u2502                                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"04-two-phase-decision-guide/#q1-is-this-a-user-triggered-action-with-side-effects","title":"Q1: Is this a user-triggered action with side effects?","text":"<p>Examples that say YES:</p> <ul> <li>\"Deploy to staging\"</li> <li>\"Run the full test suite\"</li> <li>\"Generate a new component from template\"</li> <li>\"Create a PR with our format\"</li> </ul> <p>Examples that say NO:</p> <ul> <li>\"How to deploy\" (that's knowledge, not an action)</li> <li>\"We use Jest for testing\" (that's identity)</li> </ul> <p>\u2192 YES: Go to Phase 2 \u2192 Command</p>"},{"location":"04-two-phase-decision-guide/#q2-is-this-universal-how-to-knowledge-portable-across-projects","title":"Q2: Is this universal how-to knowledge portable across projects?","text":"<p>Examples that say YES:</p> <ul> <li>\"How to implement Hexagonal Architecture\"</li> <li>\"How to write a React custom hook\"</li> <li>\"TDD workflow: red-green-refactor\"</li> <li>\"Code review best practices\"</li> </ul> <p>Examples that say NO:</p> <ul> <li>\"In this project, domain goes in <code>src/domain/</code>\" (that's project-specific)</li> <li>\"Run tests with <code>pnpm test</code>\" (that's a command)</li> </ul> <p>\u2192 YES: Go to Phase 2 \u2192 Skill</p>"},{"location":"04-two-phase-decision-guide/#q3-does-this-need-context-isolation-or-parallel-execution","title":"Q3: Does this need context isolation or parallel execution?","text":"<p>Examples that say YES:</p> <ul> <li>\"Refactor all API handlers to new pattern\"</li> <li>\"Fix these 5 independent bugs\"</li> <li>\"Experiment with a new approach without polluting context\"</li> <li>\"Large task with many planning/coding/testing steps\"</li> </ul> <p>Examples that say NO:</p> <ul> <li>\"Fix this one bug\" (simple task, no isolation needed)</li> <li>\"How to refactor\" (that's knowledge for a skill)</li> </ul> <p>\u2192 YES: Go to Phase 2 \u2192 Sub-agent</p>"},{"location":"04-two-phase-decision-guide/#q4-is-this-always-needed-project-context-or-corrections","title":"Q4: Is this always-needed project context or corrections?","text":"<p>If you've reached this question, your content is likely: - Project identity (what is this project?) - Codebase Structure (where is everything?) - Architectural guidance (how we do things here) - Iterative corrections (don't make that mistake again)</p> <p>\u2192 YES: Go to Phase 2 \u2192 CLAUDE.md / Rules</p>"},{"location":"04-two-phase-decision-guide/#visual-decision-flowchart","title":"Visual Decision Flowchart","text":"<pre><code>flowchart TD\n    START([What do I want to store?]) --&gt; Q1{Q1: User-triggered&lt;br/&gt;action with&lt;br/&gt;side effects?}\n\n    Q1 --&gt;|Yes| CMD[COMMAND]\n    Q1 --&gt;|No| Q2{Q2: Universal how-to&lt;br/&gt;knowledge, portable&lt;br/&gt;across projects?}\n\n    Q2 --&gt;|Yes| SKILL[SKILL]\n    Q2 --&gt;|No| Q3{Q3: Needs context&lt;br/&gt;isolation or&lt;br/&gt;parallel execution?}\n\n    Q3 --&gt;|Yes| AGENT[SUB-AGENT]\n    Q3 --&gt;|No| Q4{Q4: Always-needed&lt;br/&gt;context or&lt;br/&gt;corrections?}\n\n    Q4 --&gt;|Yes| CONTEXT[CLAUDE.md / RULES]\n    Q4 --&gt;|No| DOCS[External Docs&lt;br/&gt;+ Pointer]\n\n    CMD --&gt; P2CMD[Phase 2: Command]\n    SKILL --&gt; P2SKILL[Phase 2: Skill]\n    AGENT --&gt; P2AGENT[Phase 2: Sub-agent]\n    CONTEXT --&gt; P2CTX[Phase 2: CLAUDE.md/Rules]\n    DOCS --&gt; P2DOCS[Phase 2: Pointer Pattern]\n\n    style START fill:#e1f5fe\n    style CMD fill:#c8e6c9\n    style SKILL fill:#fff9c4\n    style AGENT fill:#f3e5f5\n    style CONTEXT fill:#ffe0b2\n    style DOCS fill:#f5f5f5</code></pre>"},{"location":"04-two-phase-decision-guide/#phase-2-refinement","title":"Phase 2: Refinement","text":"<p>Once you've identified the destination, use these refinement guidelines.</p> <p>Phase 2 Is Iterative\u2014Like Refactoring</p> <p>You don't need to get placement perfect on the first try. Phase 2 is like refactoring code: start with a reasonable placement, then adjust as you learn what works.</p> <ul> <li>It's OK to move things later: A skill that starts in CLAUDE.md can move to Rules</li> <li>Consider trade-offs over time: Token economy vs. precision vs. convenience</li> <li>Watch for signals: If Claude ignores a rule, maybe it's in the wrong place</li> <li>Stuck between two destinations? Use the Mechanism \u00d7 Dimension Matrix to compare trade-offs</li> </ul> <p>The goal is a working system, not a perfect one. Iterate based on real usage.</p>"},{"location":"04-two-phase-decision-guide/#phase-2-command","title":"Phase 2 \u2192 Command","text":"<p>You've determined this is a user-triggered action. Now refine:</p>"},{"location":"04-two-phase-decision-guide/#is-it-a-simple-single-action","title":"Is it a simple, single action?","text":"<p>Create a straightforward command file.</p> <pre><code>.claude/commands/deploy-staging.md\n</code></pre> <pre><code># Deploy to Staging\n\nDeploy the current branch to the staging environment.\n\n## Steps\n1. Run tests: `pnpm test`\n2. Build: `pnpm build`\n3. Deploy: `./scripts/deploy-staging.sh`\n4. Verify: `curl https://staging.example.com/health`\n</code></pre>"},{"location":"04-two-phase-decision-guide/#does-it-need-arguments","title":"Does it need arguments?","text":"<p>Use the <code>argument-hint</code> frontmatter.</p> <pre><code>---\nargument-hint: \"[environment]\"\n---\n</code></pre>"},{"location":"04-two-phase-decision-guide/#should-claude-never-auto-invoke-this","title":"Should Claude NEVER auto-invoke this?","text":"<p>Commands are user-only by default\u2014Claude cannot auto-invoke them. This is the right choice for actions with significant side effects.</p> <p>Micro-examples:</p> <ul> <li>\"Deploy to production\" \u2192 Command (explicit user action, significant side effects)</li> <li>\"Extract the deployment steps into a reusable skill\" \u2192 If the how-to knowledge is universal, refactor it from a Command into a Skill</li> </ul> <p>See Worked Examples for complete walkthroughs.</p>"},{"location":"04-two-phase-decision-guide/#phase-2-skill","title":"Phase 2 \u2192 Skill","text":"<p>You've determined this is reusable knowledge. Now refine:</p>"},{"location":"04-two-phase-decision-guide/#is-it-truly-portable","title":"Is it truly portable?","text":"<p>Check: Could this skill work in ANY project using the same technology?</p> <p>Good (portable): <pre><code># Hexagonal Architecture\n\nHexagonal Architecture separates business logic from infrastructure...\n</code></pre></p> <p>Bad (has hardcoded paths): <pre><code># Hexagonal Architecture\n\nPut domain logic in `src/domain/` and infrastructure in `src/infra/`...\n</code></pre></p> <p>If you have project-specific paths, extract them to Rules or CLAUDE.md.</p>"},{"location":"04-two-phase-decision-guide/#should-claude-auto-invoke-it","title":"Should Claude auto-invoke it?","text":"<p>By default, skills can be invoked by both user (<code>/skill-name</code>) and Claude (when relevant).</p> Control Frontmatter Default (both can invoke) (none needed) User-only <code>disable-model-invocation: true</code> Claude-only (background knowledge) <code>user-invocable: false</code>"},{"location":"04-two-phase-decision-guide/#is-it-configurable","title":"Is it configurable?","text":"<p>If the skill needs project-specific values, consider the configurable skill pattern (see Section 7 - Configurable Skills).</p> <p>Micro-example: \"How to implement repository pattern\" \u2192 Skill (universal how-to knowledge)</p> <p>See Worked Examples for complete walkthroughs.</p>"},{"location":"04-two-phase-decision-guide/#phase-2-sub-agent","title":"Phase 2 \u2192 Sub-agent","text":"<p>You've determined this needs isolation. Now refine:</p>"},{"location":"04-two-phase-decision-guide/#why-do-you-need-isolation","title":"Why do you need isolation?","text":"Reason Use Case Parallel work Multiple specialist sub-agents (frontend dev, backend dev, code reviewer) Complex multi-step Large refactoring with plan \u2192 implement \u2192 test cycle Experimentation Try an approach without polluting main context Clean handoff Get focused results back to main conversation"},{"location":"04-two-phase-decision-guide/#does-the-agent-need-special-context","title":"Does the agent need special context?","text":"<p>Agents can be configured with specific skills, tools, or instructions.</p> <pre><code># Refactoring Agent\n\nYou are a refactoring specialist. Use the `hexagonal-architecture` skill\nwhen restructuring code.\n\n## Your Task\nRefactor the authentication module to follow Hexagonal Architecture.\n\n## Constraints\n- Don't modify the API contracts\n- Maintain all existing tests\n</code></pre>"},{"location":"04-two-phase-decision-guide/#should-it-reference-skills","title":"Should it reference skills?","text":"<p>Agents should reference skills for patterns rather than duplicating knowledge. This keeps agents lightweight and focused on execution.</p> <p>Micro-examples:</p> <ul> <li>\"Refactor all API handlers\" \u2192 Sub-agent (large task, benefits from isolation)</li> <li>\"Spawn a frontend specialist and backend specialist in parallel\" \u2192 Sub-agents (domain-specific experts)</li> <li>\"Run a code reviewer agent alongside a documentation agent\" \u2192 Sub-agents (independent workstreams)</li> </ul> <p>See Worked Examples for complete walkthroughs.</p>"},{"location":"04-two-phase-decision-guide/#sub-agents-dont-inherit-claudemd-skills-or-rules-use-skills-frontmatter-for-custom-agents-or-pass-content-in-the-prompt-for-ad-hoc-spawns-see-section-3-sub-agent-context-isolation-for-details","title":"&gt; \u26a0\ufe0f Sub-agents don't inherit CLAUDE.md, skills, or rules. Use <code>skills:</code> frontmatter for custom agents, or pass content in the prompt for ad-hoc spawns. See Section 3 \u2014 Sub-agent Context Isolation for details.","text":""},{"location":"04-two-phase-decision-guide/#phase-2-claudemd-rules","title":"Phase 2 \u2192 CLAUDE.md / Rules","text":"<p>You've determined this is always-needed context. Now refine:</p>"},{"location":"04-two-phase-decision-guide/#is-it-project-identity-or-structure","title":"Is it project identity or structure?","text":"<p>\u2192 CLAUDE.md</p> <pre><code># Project: ShopFlow\nB2B e-commerce platform for wholesale distributors.\n\n## Stack\nNext.js 14, TypeScript, Prisma, PostgreSQL\n\n## Structure\n- `src/app/` - Next.js app router pages\n- `src/components/` - React components\n- `src/lib/` - Shared utilities\n</code></pre>"},{"location":"04-two-phase-decision-guide/#is-it-tied-to-specific-file-patterns","title":"Is it tied to specific file patterns?","text":"<p>\u2192 Rules</p> <pre><code># .claude/rules/typescript.md\n---\nglobs: [\"*.ts\", \"*.tsx\"]\n---\n\n# TypeScript Conventions\n\n- Use `unknown` instead of `any`\n- Prefer interfaces over types for object shapes\n- Always specify return types for functions\n</code></pre>"},{"location":"04-two-phase-decision-guide/#is-it-a-correction-for-repeated-mistakes","title":"Is it a correction for repeated mistakes?","text":"<p>\u2192 Rules (targeted) or CLAUDE.md (if critical and universal)</p> <pre><code># .claude/rules/prisma.md\n---\nglobs: [\"prisma/**\", \"*.prisma\"]\n---\n\n# Prisma Rules\n\n- Never INSERT directly to `user` table - use `create_user()` function\n- Always include `deleted_at IS NULL` in queries\n</code></pre>"},{"location":"04-two-phase-decision-guide/#is-it-too-long-for-claudemd","title":"Is it too long for CLAUDE.md?","text":"<p>Use the pointer pattern: keep brief reference in CLAUDE.md, full content in external docs.</p> <pre><code># In CLAUDE.md\nSee `docs/architecture.md` for full architecture documentation.\n</code></pre> <p>Micro-example: \"We use PostgreSQL with Prisma\" \u2192 CLAUDE.md (project identity, always needed)</p> <p>See Worked Examples for complete walkthroughs.</p>"},{"location":"04-two-phase-decision-guide/#phase-2-pointer-pattern-external-docs","title":"Phase 2 \u2192 Pointer Pattern (External Docs)","text":"<p>Recall Q4: \"Is this always-needed project context or corrections?\" (identity, structure, rules, fixes)</p> <p>If you answered \"No\" to Q4, your content might be: - Detailed documentation that's too long for CLAUDE.md - Reference material not needed in every conversation - Historical context or explanations</p>"},{"location":"04-two-phase-decision-guide/#use-the-pointer-pattern","title":"Use the pointer pattern:","text":"<ol> <li>Store full content in <code>docs/</code> folder</li> <li>Add brief pointer in CLAUDE.md or relevant skill</li> </ol> <pre><code># In CLAUDE.md\n## Documentation\n- Architecture: `docs/architecture.md`\n- Testing philosophy: `docs/testing.md`\n- API reference: `docs/api.md`\n</code></pre> <p>Claude will read these files when relevant, but they won't consume tokens in every message.</p>"},{"location":"04-two-phase-decision-guide/#quick-decision-reference","title":"Quick Decision Reference","text":"If your content is... Then use... Because... A workflow/action users trigger Command Explicit control, side effects Universal how-to knowledge Skill Reusable, on-demand, portable Large/complex isolated task Sub-agent Context isolation, parallelization Project identity/structure CLAUDE.md Always needed, minimal tokens File-type conventions Rules Pattern-triggered, contextual Mistake corrections Rules Automatic enforcement Long reference docs External + Pointer Token economy"},{"location":"04-two-phase-decision-guide/#common-patterns","title":"Common Patterns","text":"<p>Phase 2 sometimes reveals that a single piece of knowledge spans multiple categories. When that happens, decompose it across mechanisms \u2014 each part goes where it fits best.</p>"},{"location":"04-two-phase-decision-guide/#pattern-we-use-x-technology","title":"Pattern: \"We use X technology\"","text":"<ul> <li>Identity statement (e.g., \"We use PostgreSQL\") \u2192 CLAUDE.md</li> <li>How to use it (e.g., \"How to write Prisma queries\") \u2192 Skill</li> <li>Our conventions (e.g., \"Always use soft deletes\") \u2192 Rules</li> </ul>"},{"location":"04-two-phase-decision-guide/#pattern-runbuilddeploy-something","title":"Pattern: \"Run/Build/Deploy something\"","text":"<ul> <li>The action itself \u2192 Command</li> <li>How the process works (if teaching) \u2192 Skill</li> <li>Prerequisites (e.g., \"Requires Docker running\") \u2192 CLAUDE.md</li> </ul>"},{"location":"04-two-phase-decision-guide/#pattern-follow-this-coding-standard","title":"Pattern: \"Follow this coding standard\"","text":"<ul> <li>Universal standard (e.g., \"SOLID principles\") \u2192 Skill</li> <li>Our specific rules (e.g., \"Use kebab-case for files\") \u2192 Rules</li> <li>Why we do it (if long explanation) \u2192 External docs + pointer</li> </ul>"},{"location":"04-two-phase-decision-guide/#pattern-enforce-an-architectural-standard","title":"Pattern: \"Enforce an architectural standard\"","text":"<ul> <li>The pattern itself (e.g., \"Repository Pattern principles\") \u2192 Skill</li> <li>Our conventions (e.g., \"Repos live in <code>src/repos/</code>, use Prisma\") \u2192 Rule</li> <li>An agent that applies it (e.g., \"Refactor all data access to use repos\") \u2192 Sub-agent referencing the Skill</li> </ul>"},{"location":"04-two-phase-decision-guide/#summary","title":"Summary","text":"<p>Phase 1 Triage gets you to the right destination:</p> <ol> <li>User-triggered action? \u2192 Command</li> <li>Universal how-to? \u2192 Skill</li> <li>Needs isolation? \u2192 Sub-agent</li> <li>Always-needed context? \u2192 CLAUDE.md / Rules</li> </ol> <p>Phase 2 Refinement helps you finalize:</p> <ul> <li>Commands: Simple vs. complex, arguments, user-only (default)</li> <li>Skills: Portable check, invocation control, configurable pattern</li> <li>Sub-agents: Isolation reason, context needs, skill references</li> <li>CLAUDE.md/Rules: Identity vs. patterns, file triggers, pointer pattern</li> </ul> <p>For most decisions, Phase 1 is enough. Phase 2 handles the nuances.</p> <p>Previous: Section 3 - The Storage Options Next: Section 5 - CLAUDE.md Best Practices</p>"},{"location":"05-claudemd-best-practices/","title":"Section 5: CLAUDE.md Best Practices","text":"<p>CLAUDE.md is the most important\u2014and most frequently misused\u2014Claude Code memory mechanism. Because it's always loaded, every token occupies context window space in every message. This section provides practical guidance for keeping your CLAUDE.md lean, maintainable, and effective.</p>"},{"location":"05-claudemd-best-practices/#the-token-economy-principle","title":"The Token Economy Principle","text":""},{"location":"05-claudemd-best-practices/#why-every-token-matters","title":"Why Every Token Matters","text":"<p>CLAUDE.md is included in the system prompt for every message in a conversation. The Claude API is stateless \u2014 each request sends the full prompt (system prompt + history + new message). Unlike Skills or Commands that load on-demand, CLAUDE.md tokens are present in every exchange.</p> <p>Tokens processed per conversation: <pre><code>Total Tokens Processed = CLAUDE.md Tokens \u00d7 Number of Messages\n</code></pre></p> CLAUDE.md Size 10 Messages 50 Messages 100 Messages 100 tokens 1,000 5,000 10,000 500 tokens 5,000 25,000 50,000 2,000 tokens 20,000 100,000 200,000 <p>A 2,000-token CLAUDE.md occupies 20x more context window space than a 100-token CLAUDE.md over the same conversation.</p> <p>Prompt caching reduces financial cost, not context pressure</p> <p>Claude Code automatically uses prompt caching. After the first message, stable repeated content (like CLAUDE.md) is read from cache at 10% of the base input token price \u2014 a ~90% cost reduction. The first write costs 1.25x base price.</p> Message Financial cost (per token) First message 1.25x base (cache write) Subsequent messages 0.1x base (cache read) <p>However, cached tokens still occupy context window space. The context window is the binding constraint \u2014 not price. A bloated CLAUDE.md crowds out room for conversation history, tool results, and reasoning. This is why minimizing CLAUDE.md remains critical even with caching.</p>"},{"location":"05-claudemd-best-practices/#the-target","title":"The Target","text":"<p>Keep CLAUDE.md under 100-200 tokens.</p> <p>This isn't arbitrary\u2014it's the sweet spot where you have enough context to orient Claude without paying excessive token costs. Everything beyond essential identity should live elsewhere.</p>"},{"location":"05-claudemd-best-practices/#what-this-means-practically","title":"What This Means Practically","text":"<p>Ask yourself: \"Does Claude need this in every single message exchange?\"</p> <ul> <li>Yes \u2192 Keep in CLAUDE.md (but keep it brief)</li> <li>No \u2192 Move to Skills, Rules, Commands, or external docs</li> </ul>"},{"location":"05-claudemd-best-practices/#the-pointer-pattern","title":"The Pointer Pattern","text":""},{"location":"05-claudemd-best-practices/#claudemd-is-a-table-of-contents-not-the-book","title":"CLAUDE.md Is a Table of Contents, Not the Book","text":"<p>Think of CLAUDE.md as a directory or index\u2014not a comprehensive document. It should tell Claude what exists and where to find it, not contain all the details.</p>"},{"location":"05-claudemd-best-practices/#bad-example-bloated","title":"Bad Example (Bloated)","text":"<pre><code># Project: ShopFlow\n\n## Tech Stack\n- Next.js 14 with App Router\n- TypeScript 5.3 with strict mode\n- Prisma ORM with PostgreSQL\n- Redis for caching\n- Stripe for payments\n- SendGrid for emails\n\n## Architecture\nWe use Hexagonal Architecture with the following structure:\n- Domain layer in src/domain/ contains all business logic\n- Application layer in src/application/ contains use cases\n- Infrastructure layer in src/infrastructure/ contains adapters\n- Presentation layer in src/presentation/ contains API routes\n[... 50 more lines of architecture details ...]\n\n## Testing\nWe use Jest for unit tests and Playwright for E2E tests.\nTo run tests:\n- Unit tests: pnpm test\n- E2E tests: pnpm test:e2e\n- Coverage: pnpm test:coverage\nTest files should be colocated with source files using .test.ts extension.\n[... 30 more lines of testing conventions ...]\n\n## Coding Standards\n- Use functional components with hooks\n- No class components\n- Prefer named exports\n- Use barrel files for public APIs\n[... 40 more lines of coding standards ...]\n</code></pre> <p>Token count: ~800-1,000 tokens \u2014 loaded in every message.</p>"},{"location":"05-claudemd-best-practices/#good-example-pointer-pattern","title":"Good Example (Pointer Pattern)","text":"<pre><code># ShopFlow\n\nB2B e-commerce platform. Next.js 14, TypeScript, Prisma, PostgreSQL.\n\n## Structure\n- `src/domain/` - Business logic\n- `src/application/` - Use cases\n- `src/infrastructure/` - Adapters\n- `src/presentation/` - API routes\n\n## Quick Commands\n- Tests: `pnpm test`\n- Dev: `pnpm dev`\n\n## Documentation\n- Architecture: `docs/architecture.md`\n- Testing: `docs/testing.md`\n- Conventions: `docs/conventions.md`\n</code></pre> <p>Token count: ~80-100 tokens \u2014 10x smaller, same essential information.</p>"},{"location":"05-claudemd-best-practices/#discovery-anchors","title":"Discovery Anchors","text":"<p>A Discovery Anchor is a brief pointer that tells Claude where to find detailed information when needed. Claude will read these files when the context requires it.</p> <p>Pattern: <pre><code>## [Topic]\nSee `path/to/detailed-docs.md` for [what's there].\n</code></pre></p> <p>Examples: <pre><code>## Architecture\nSee `docs/architecture.md` for full system design.\n\n## Testing\nRun `/test` or see `.claude/commands/test.md` for testing workflow.\n\n## Coding Standards\nTypeScript conventions in `.claude/rules/typescript.md`.\n</code></pre></p>"},{"location":"05-claudemd-best-practices/#recommended-structure","title":"Recommended Structure","text":""},{"location":"05-claudemd-best-practices/#the-minimal-claudemd-template","title":"The Minimal CLAUDE.md Template","text":"<pre><code># [Project Name]\n\n[One-sentence description of what this project does.]\n\n## Stack\n[Technology list - keep to essentials]\n\n## Structure\n[Key directories only - 3-5 lines max]\n\n## Commands\n[Most common commands - 2-3 lines max]\n\n## Docs\n[Pointers to detailed documentation]\n</code></pre>"},{"location":"05-claudemd-best-practices/#section-by-section-guidance","title":"Section-by-Section Guidance","text":""},{"location":"05-claudemd-best-practices/#1-header-required","title":"1. Header (Required)","text":"<ul> <li>Project name</li> <li>One-sentence description</li> <li>Keep to 1-2 lines</li> </ul>"},{"location":"05-claudemd-best-practices/#2-stack-required","title":"2. Stack (Required)","text":"<ul> <li>Core technologies only</li> <li>No version numbers unless critical</li> <li>Keep to 1 line if possible</li> </ul>"},{"location":"05-claudemd-best-practices/#3-structure-required","title":"3. Structure (Required)","text":"<ul> <li>Only the directories Claude needs to navigate</li> <li>Skip obvious ones (<code>node_modules/</code>, <code>.git/</code>)</li> <li>Keep to 3-5 lines</li> </ul>"},{"location":"05-claudemd-best-practices/#4-commands-optional","title":"4. Commands (Optional)","text":"<ul> <li>Only the commands you use constantly</li> <li>Full workflows belong in Commands (<code>.claude/commands/</code>)</li> <li>Keep to 2-3 lines</li> </ul>"},{"location":"05-claudemd-best-practices/#5-docs-recommended","title":"5. Docs (Recommended)","text":"<ul> <li>Pointers to external documentation</li> <li>This is where detailed content lives</li> <li>Keep to 2-4 lines</li> </ul>"},{"location":"05-claudemd-best-practices/#6-critical-constraints-if-any","title":"6. Critical Constraints (If Any)","text":"<ul> <li>\"Never modify X\"</li> <li>\"Always check Y before Z\"</li> <li>Only include if violations are costly</li> <li>Keep to 1-2 lines if needed</li> </ul>"},{"location":"05-claudemd-best-practices/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"05-claudemd-best-practices/#anti-pattern-1-full-architecture-documentation","title":"Anti-Pattern 1: Full Architecture Documentation","text":"<p>\u274c Bad: <pre><code>## Architecture\n\nWe use Hexagonal Architecture (also known as Ports and Adapters).\n\nThe core principle is that business logic should be isolated from\ninfrastructure concerns. The domain layer contains pure business rules\nwith no dependencies on external systems...\n\n[200+ more words explaining hexagonal architecture]\n</code></pre></p> <p>\u2705 Good: <pre><code>## Architecture\nHexagonal Architecture. See `docs/architecture.md` for details.\n</code></pre></p> <p>Why: Architecture explanations are universal knowledge\u2014put them in a Skill. Project-specific structure goes in CLAUDE.md briefly; details go in external docs.</p>"},{"location":"05-claudemd-best-practices/#anti-pattern-2-complete-test-commands","title":"Anti-Pattern 2: Complete Test Commands","text":"<p>\u274c Bad: <pre><code>## Testing\n\nTo run all tests:\npnpm test\n\nTo run specific tests:\npnpm test -- --grep \"pattern\"\n\nTo run with coverage:\npnpm test:coverage\n\nTo run E2E tests:\npnpm test:e2e\n\nTo run in watch mode:\npnpm test:watch\n\nBefore submitting a PR, always run:\n1. pnpm lint\n2. pnpm test\n3. pnpm build\n</code></pre></p> <p>\u2705 Good: <pre><code>## Tests\nRun `/test` for full test workflow. Quick: `pnpm test`\n</code></pre></p> <p>Why: Full testing workflows belong in a Command (<code>.claude/commands/test.md</code>). CLAUDE.md only needs the quick reference.</p>"},{"location":"05-claudemd-best-practices/#anti-pattern-3-inline-code-style-guides","title":"Anti-Pattern 3: Inline Code Style Guides","text":"<p>\u274c Bad: <pre><code>## Code Style\n\n- Use functional components, never class components\n- Prefer named exports over default exports\n- Use TypeScript strict mode\n- No `any` types - use `unknown` and narrow\n- Components should have a single responsibility\n- Use hooks for state management\n- Prefer composition over inheritance\n- Use barrel files for public APIs\n- File names should be kebab-case\n- Component names should be PascalCase\n[... continues for 30 more lines ...]\n</code></pre></p> <p>\u2705 Good: <pre><code>## Style\nTypeScript + React conventions in `.claude/rules/`.\n</code></pre></p> <p>Why: Code style rules should live in Rules (triggered when editing relevant files) or external docs. CLAUDE.md just points to them.</p> <p>When to Use Rules vs External Files</p> Content Type Use Rules Use External Files TypeScript conventions \u2713 (glob: <code>*.ts</code>) Test file patterns \u2713 (glob: <code>*.test.*</code>) General coding standards \u2713 + pointer Architecture guidelines \u2713 + pointer <p>Key insight: Rules only save tokens when they have specific glob patterns. General content that isn't file-type-specific should use external files with a pointer in CLAUDE.md.</p>"},{"location":"05-claudemd-best-practices/#anti-pattern-4-long-lists-of-rules","title":"Anti-Pattern 4: Long Lists of Rules","text":"<p>\u274c Bad: <pre><code>## Rules\n\n1. Never commit directly to main\n2. Always create feature branches\n3. Run tests before pushing\n4. Use conventional commits\n5. No console.log in production code\n6. Always handle errors\n7. No magic numbers\n8. Use constants for repeated values\n[... 20 more rules ...]\n</code></pre></p> <p>\u2705 Good: <pre><code>## Conventions\nSee `docs/conventions.md`. Key: conventional commits, feature branches.\n</code></pre></p> <p>Why: Rules lists grow unbounded. Keep the top 1-2 critical ones inline; everything else goes to external docs or Rules files.</p>"},{"location":"05-claudemd-best-practices/#self-assessment-checklist","title":"Self-Assessment Checklist","text":"<p>Use this checklist to evaluate your CLAUDE.md:</p>"},{"location":"05-claudemd-best-practices/#token-economy","title":"Token Economy","text":"<ul> <li>[ ] Under 200 tokens total?</li> <li>[ ] No content that could live in Skills, Rules, or Commands?</li> <li>[ ] Using pointer pattern for detailed documentation?</li> </ul>"},{"location":"05-claudemd-best-practices/#structure","title":"Structure","text":"<ul> <li>[ ] Clear project identity (name + one-sentence description)?</li> <li>[ ] Essential tech stack only?</li> <li>[ ] Key directories only (3-5 max)?</li> <li>[ ] Common commands only (2-3 max)?</li> </ul>"},{"location":"05-claudemd-best-practices/#content-quality","title":"Content Quality","text":"<ul> <li>[ ] No full architecture documentation inline?</li> <li>[ ] No complete style guides inline?</li> <li>[ ] No long lists of rules?</li> <li>[ ] No step-by-step procedures (those are Commands)?</li> </ul>"},{"location":"05-claudemd-best-practices/#discovery-anchors_1","title":"Discovery Anchors","text":"<ul> <li>[ ] Pointing to external docs where appropriate?</li> <li>[ ] Claude can find detailed information when needed?</li> </ul>"},{"location":"05-claudemd-best-practices/#before-and-after-complete-example","title":"Before and After: Complete Example","text":""},{"location":"05-claudemd-best-practices/#before-bloated-600-tokens","title":"Before (Bloated - ~600 tokens)","text":"<pre><code># ShopFlow E-Commerce Platform\n\nShopFlow is a B2B e-commerce platform designed for wholesale distributors\nto manage their product catalogs, process orders, and handle customer\nrelationships.\n\n## Technology Stack\n- **Frontend**: Next.js 14 with App Router, React 18, TypeScript 5.3\n- **Styling**: Tailwind CSS 3.4, Radix UI components\n- **Backend**: Next.js API Routes, tRPC for type-safe APIs\n- **Database**: PostgreSQL 15 with Prisma ORM\n- **Caching**: Redis for session storage and query caching\n- **Authentication**: NextAuth.js with JWT tokens\n- **Payments**: Stripe for payment processing\n- **Email**: SendGrid for transactional emails\n- **Storage**: AWS S3 for product images\n- **Hosting**: Vercel for frontend, Railway for database\n\n## Project Structure\nsrc/\n\u251c\u2500\u2500 app/                 # Next.js App Router pages\n\u2502   \u251c\u2500\u2500 (auth)/         # Authentication routes\n\u2502   \u251c\u2500\u2500 (dashboard)/    # Main dashboard routes\n\u2502   \u2514\u2500\u2500 api/            # API routes\n\u251c\u2500\u2500 components/         # React components\n\u2502   \u251c\u2500\u2500 ui/            # Base UI components\n\u2502   \u251c\u2500\u2500 forms/         # Form components\n\u2502   \u2514\u2500\u2500 layouts/       # Layout components\n\u251c\u2500\u2500 lib/               # Utility functions\n\u251c\u2500\u2500 hooks/             # Custom React hooks\n\u251c\u2500\u2500 stores/            # Zustand stores\n\u251c\u2500\u2500 types/             # TypeScript types\n\u2514\u2500\u2500 server/            # Server-side code\n    \u251c\u2500\u2500 db/            # Database utilities\n    \u251c\u2500\u2500 services/      # Business logic\n    \u2514\u2500\u2500 trpc/          # tRPC routers\n\n## Development Commands\n- Start dev server: `pnpm dev`\n- Run tests: `pnpm test`\n- Run E2E tests: `pnpm test:e2e`\n- Lint code: `pnpm lint`\n- Format code: `pnpm format`\n- Build: `pnpm build`\n- Database migrations: `pnpm db:migrate`\n- Seed database: `pnpm db:seed`\n\n## Coding Standards\n- Always use TypeScript strict mode\n- No `any` types allowed\n- Use functional components only\n- Prefer named exports\n- Use Tailwind for styling, no CSS files\n- All components must have tests\n</code></pre>"},{"location":"05-claudemd-best-practices/#after-lean-100-tokens","title":"After (Lean - ~100 tokens)","text":"<pre><code># ShopFlow\n\nB2B e-commerce for wholesale distributors.\n\n## Stack\nNext.js 14, TypeScript, Prisma, PostgreSQL, Stripe, Tailwind\n\n## Structure\n- `src/app/` - Pages (App Router)\n- `src/components/` - React components\n- `src/server/` - API &amp; business logic\n\n## Commands\nDev: `pnpm dev` | Tests: `pnpm test` | Build: `pnpm build`\n\n## Docs\n- Architecture: `docs/architecture.md`\n- API: `docs/api.md`\n- Conventions: `docs/conventions.md`\n</code></pre> <p>Result: Same essential information, 6x fewer tokens, better maintainability.</p>"},{"location":"05-claudemd-best-practices/#summary","title":"Summary","text":"<ol> <li> <p>Token Economy: Every CLAUDE.md token occupies context window space in every message. Prompt caching reduces the financial cost (~90% after the first message), but the context window pressure remains. Target 100-200 tokens.</p> </li> <li> <p>Pointer Pattern: CLAUDE.md is an index, not the book. Point to detailed docs.</p> </li> <li> <p>Essential Content Only:</p> </li> <li>Project identity (name + one-liner)</li> <li>Core tech stack</li> <li>Key directories (3-5)</li> <li>Common commands (2-3)</li> <li> <p>Documentation pointers</p> </li> <li> <p>Avoid Anti-Patterns:</p> </li> <li>No full architecture docs</li> <li>No complete style guides</li> <li>No long rule lists</li> <li> <p>No step-by-step procedures</p> </li> <li> <p>Use the Checklist: Regularly audit your CLAUDE.md against the self-assessment.</p> </li> </ol> <p>Previous: Section 4 - Two-Phase Decision Guide Next: Section 6 - Migration Guide</p>"},{"location":"06-migration-guide/","title":"Section 6: Migration Guide","text":"<p>Most projects start with a messy, bloated CLAUDE.md\u2014and that's okay. You don't need to over-engineer from day one. But when your CLAUDE.md grows unwieldy or you want to share patterns across projects, it's time to migrate.</p> <p>This guide provides a step-by-step process for reorganizing your existing CLAUDE.md using the TrigMem methodology.</p>"},{"location":"06-migration-guide/#when-to-migrate","title":"When to Migrate","text":""},{"location":"06-migration-guide/#signs-you-need-migration","title":"Signs You Need Migration","text":"<ul> <li>[ ] CLAUDE.md is over 200 lines</li> <li>[ ] Claude seems to ignore some instructions (context overload)</li> <li>[ ] You want to reuse patterns in another project</li> <li>[ ] Team members keep overwriting each other's instructions</li> <li>[ ] You're hitting token limits in long conversations</li> </ul>"},{"location":"06-migration-guide/#when-not-to-migrate","title":"When NOT to Migrate","text":"<ul> <li>Your CLAUDE.md is small and working fine</li> <li>You're in the middle of a critical sprint</li> <li>The project is short-lived or throwaway</li> </ul> <p>Rule of thumb: If it's not causing problems, don't fix it. Migrate when the pain exceeds the effort.</p>"},{"location":"06-migration-guide/#the-3-step-migration-process","title":"The 3-Step Migration Process","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        THE MIGRATION PROCESS                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                             \u2502\n\u2502  STEP 1: AUDIT                                                              \u2502\n\u2502  Tag every section with its Information Category (1-6)                      \u2502\n\u2502                                                                             \u2502\n\u2502  STEP 2: SPLIT                                                              \u2502\n\u2502  Move each category to its proper destination                               \u2502\n\u2502                                                                             \u2502\n\u2502  STEP 3: LINK                                                               \u2502\n\u2502  Replace moved content with Discovery Anchors                               \u2502\n\u2502                                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"06-migration-guide/#step-1-audit","title":"Step 1: Audit","text":""},{"location":"06-migration-guide/#what-youre-doing","title":"What You're Doing","text":"<p>Reading through your CLAUDE.md and tagging every section with one of the 6 Information Categories from Section 2.</p>"},{"location":"06-migration-guide/#the-category-reference","title":"The Category Reference","text":"# Category Quick Test 1 Project Identity \"What is this project?\" 2 Codebase Structure \"Where is everything?\" 3 Operational Commands \"How do I run/build/deploy?\" 4 Reusable Patterns \"Universal how-to knowledge\" 5 Architectural Guidance \"Our specific conventions\" 6 Iterative Corrections \"Don't make that mistake again\""},{"location":"06-migration-guide/#how-to-tag","title":"How to Tag","text":"<p>Add category markers directly in your CLAUDE.md (you'll remove them after migration):</p> <pre><code># MyProject                           &lt;!-- Cat 1: Identity --&gt;\n\nA React e-commerce application.       &lt;!-- Cat 1: Identity --&gt;\n\n## Tech Stack                         &lt;!-- Cat 1: Identity --&gt;\n- React 18, TypeScript, Tailwind\n- Node.js, Express, PostgreSQL\n\n## Project Structure                  &lt;!-- Cat 2: Map --&gt;\n- src/components/ - React components\n- src/api/ - Express routes\n- src/db/ - Database utilities\n\n## Testing                            &lt;!-- Cat 3: Commands --&gt;\nRun all tests: `npm test`\nRun with coverage: `npm test:coverage`\nE2E tests: `npm run test:e2e`\n\nBefore PR:\n1. Run lint\n2. Run tests\n3. Build\n\n## Component Patterns                 &lt;!-- Cat 4: Reusable Pattern --&gt;\nAll components should:\n- Use functional components with hooks\n- Have a single responsibility\n- Include PropTypes or TypeScript types\n[... 30 lines of patterns ...]\n\n## Our Conventions                    &lt;!-- Cat 5: Architectural Guidance --&gt;\n- Components go in src/components/{Feature}/\n- API routes follow REST conventions\n- Database queries use raw SQL, not ORM\n\n## Rules                              &lt;!-- Cat 6: Corrections --&gt;\n- Never use `any` in TypeScript\n- Always handle loading/error states\n- Don't commit console.log statements\n</code></pre>"},{"location":"06-migration-guide/#audit-checklist","title":"Audit Checklist","text":"<p>After tagging, verify: - [ ] Every section has a category tag - [ ] No section is tagged with multiple categories (split if needed) - [ ] You understand why each tag applies</p>"},{"location":"06-migration-guide/#step-2-split","title":"Step 2: Split","text":""},{"location":"06-migration-guide/#what-youre-doing_1","title":"What You're Doing","text":"<p>Moving content from CLAUDE.md to its proper destination based on category.</p>"},{"location":"06-migration-guide/#the-destination-map","title":"The Destination Map","text":"Category Destination File Location 1. Project Identity Keep in CLAUDE.md <code>CLAUDE.md</code> 2. Codebase Structure Keep in CLAUDE.md (brief) <code>CLAUDE.md</code> 3. Operational Commands Commands <code>.claude/commands/{name}.md</code> 4. Reusable Patterns Skills <code>.claude/skills/{name}/SKILL.md</code> 5. Architectural Guidance Rules or Docs <code>.claude/rules/{name}.md</code> or <code>docs/</code> 6. Iterative Corrections Rules <code>.claude/rules/{name}.md</code>"},{"location":"06-migration-guide/#creating-commands-category-3","title":"Creating Commands (Category 3)","text":"<p>For operational workflows, create command files:</p> <p>Before (in CLAUDE.md): <pre><code>## Testing\nRun all tests: `npm test`\nRun with coverage: `npm test:coverage`\nE2E tests: `npm run test:e2e`\n\nBefore PR:\n1. Run lint\n2. Run tests\n3. Build\n</code></pre></p> <p>After (in <code>.claude/commands/test.md</code>): <pre><code># Test\n\nRun the test suite for this project.\n\n## Quick Test\nnpm test\n\n## Full Test Workflow\n1. Run linting: `npm run lint`\n2. Run unit tests: `npm test`\n3. Run E2E tests: `npm run test:e2e`\n4. Check coverage: `npm test:coverage`\n\n## Before PR Checklist\n- [ ] All tests pass\n- [ ] Coverage meets threshold\n- [ ] No linting errors\n</code></pre></p>"},{"location":"06-migration-guide/#creating-skills-category-4","title":"Creating Skills (Category 4)","text":"<p>For reusable patterns, create skill directories:</p> <p>Before (in CLAUDE.md): <pre><code>## Component Patterns\nAll components should:\n- Use functional components with hooks\n- Have a single responsibility\n- Include PropTypes or TypeScript types\n- Be tested with React Testing Library\n[... detailed patterns ...]\n</code></pre></p> <p>After (in <code>.claude/skills/react-components/SKILL.md</code>): <pre><code>---\nname: react-components\ndescription: |\n  React component patterns and best practices.\n  Use when creating or reviewing React components.\n---\n\n# React Component Patterns\n\n## Core Principles\n- Use functional components with hooks\n- Single responsibility per component\n- Include TypeScript types for all props\n\n## Component Structure\n[... detailed patterns ...]\n</code></pre></p>"},{"location":"06-migration-guide/#creating-rules-categories-5-6","title":"Creating Rules (Categories 5 &amp; 6)","text":"<p>For conventions and corrections, create rule files:</p> <p>Before (in CLAUDE.md): <pre><code>## Rules\n- Never use `any` in TypeScript\n- Always handle loading/error states\n- Don't commit console.log statements\n</code></pre></p> <p>After (in <code>.claude/rules/typescript.md</code>): <pre><code>---\nglobs: [\"*.ts\", \"*.tsx\"]\n---\n\n# TypeScript Rules\n\n- Use `unknown` instead of `any` - narrow the type explicitly\n- Always handle loading and error states in async operations\n- Remove all console.log statements before committing\n</code></pre></p>"},{"location":"06-migration-guide/#moving-to-docs-long-content","title":"Moving to Docs (Long Content)","text":"<p>For detailed documentation that doesn't fit Rules or Skills:</p> <p>Before (in CLAUDE.md): <pre><code>## Architecture\nWe use a modified MVC pattern with the following structure:\n[... 50+ lines of architecture explanation ...]\n</code></pre></p> <p>After (in <code>docs/architecture.md</code>): <pre><code># Architecture\n\nWe use a modified MVC pattern with the following structure:\n[... full content ...]\n</code></pre></p>"},{"location":"06-migration-guide/#file-naming-guide","title":"File Naming Guide","text":"Type Convention Example Commands <code>{action}.md</code> <code>test.md</code>, <code>deploy.md</code>, <code>build.md</code> Skills <code>{name}/SKILL.md</code> <code>react-components/SKILL.md</code> Rules <code>{scope}.md</code> <code>typescript.md</code>, <code>api-routes.md</code> Docs <code>{topic}.md</code> <code>architecture.md</code>, <code>conventions.md</code>"},{"location":"06-migration-guide/#step-3-link","title":"Step 3: Link","text":""},{"location":"06-migration-guide/#what-youre-doing_2","title":"What You're Doing","text":"<p>Replacing the moved content with Discovery Anchors\u2014brief pointers that tell Claude where to find detailed information.</p>"},{"location":"06-migration-guide/#the-discovery-anchor-pattern","title":"The Discovery Anchor Pattern","text":"<pre><code>## [Topic]\n[One-line summary]. See `path/to/file` for details.\n</code></pre> <p>Or for commands:</p> <pre><code>## [Topic]\nRun `/command-name` or see `.claude/commands/command-name.md`.\n</code></pre>"},{"location":"06-migration-guide/#before-and-after-example","title":"Before and After Example","text":"<p>Before Migration (~400 tokens): <pre><code># MyProject\n\nA React e-commerce application.\n\n## Tech Stack\n- React 18, TypeScript, Tailwind\n- Node.js, Express, PostgreSQL\n\n## Project Structure\n- src/components/ - React components\n- src/api/ - Express routes\n- src/db/ - Database utilities\n\n## Testing\nRun all tests: `npm test`\nRun with coverage: `npm test:coverage`\nE2E tests: `npm run test:e2e`\n\nBefore PR:\n1. Run lint\n2. Run tests\n3. Build\n\n## Component Patterns\nAll components should:\n- Use functional components with hooks\n- Have a single responsibility\n- Include PropTypes or TypeScript types\n[... 30 more lines ...]\n\n## Our Conventions\n- Components go in src/components/{Feature}/\n- API routes follow REST conventions\n- Database queries use raw SQL, not ORM\n\n## Rules\n- Never use `any` in TypeScript\n- Always handle loading/error states\n- Don't commit console.log statements\n</code></pre></p> <p>After Migration (~100 tokens): <pre><code># MyProject\n\nReact e-commerce app. React 18, TypeScript, Node.js, PostgreSQL.\n\n## Structure\n- `src/components/` - React components\n- `src/api/` - Express routes\n- `src/db/` - Database utilities\n\n## Commands\n- Tests: `/test` or `npm test`\n- Build: `npm run build`\n\n## Docs\n- Conventions: `docs/conventions.md`\n- Architecture: `docs/architecture.md`\n</code></pre></p> <p>Files Created:</p> <ul> <li><code>.claude/commands/test.md</code> - Testing workflow</li> <li><code>.claude/skills/react-components/SKILL.md</code> - Component patterns</li> <li><code>.claude/rules/typescript.md</code> - TypeScript rules</li> <li><code>docs/conventions.md</code> - Project conventions</li> </ul>"},{"location":"06-migration-guide/#verification-checklist","title":"Verification Checklist","text":"<p>After migration, verify:</p> <ul> <li>[ ] CLAUDE.md is under 200 tokens (ideally under 100)</li> <li>[ ] Every piece of content exists somewhere (nothing lost)</li> <li>[ ] Discovery Anchors point to correct files</li> <li>[ ] Commands work when invoked (<code>/test</code>, etc.)</li> <li>[ ] Skills are recognized by Claude</li> </ul>"},{"location":"06-migration-guide/#common-migration-scenarios","title":"Common Migration Scenarios","text":""},{"location":"06-migration-guide/#scenario-1-greenfield-project","title":"Scenario 1: Greenfield Project","text":"<p>Situation: Starting a new project, want to do it right from the start.</p> <p>Approach:</p> <ol> <li>Create minimal CLAUDE.md with identity and structure only</li> <li>Create Skills for your standard patterns as you develop them</li> <li>Add Rules as you encounter repeated corrections</li> <li>Create Commands for workflows you repeat</li> </ol> <p>Starting Template: <pre><code># [ProjectName]\n\n[One-sentence description].\n\n## Stack\n[Technologies]\n\n## Structure\n- `src/` - Source code\n- `tests/` - Test files\n\n## Docs\nSee `docs/` for detailed documentation.\n</code></pre></p>"},{"location":"06-migration-guide/#scenario-2-brownfield-with-small-claudemd","title":"Scenario 2: Brownfield with Small CLAUDE.md","text":"<p>Situation: Existing project with a CLAUDE.md under 200 lines that works okay.</p> <p>Approach:</p> <ol> <li>Don't migrate yet\u2014if it works, keep it</li> <li>When you want to reuse a pattern, extract just that pattern to a Skill</li> <li>Migrate incrementally as patterns emerge</li> </ol> <p>Rule: Only migrate when the pain exceeds the effort.</p>"},{"location":"06-migration-guide/#scenario-3-brownfield-with-huge-claudemd","title":"Scenario 3: Brownfield with Huge CLAUDE.md","text":"<p>Situation: CLAUDE.md has grown to 500+ lines, Claude ignores some instructions.</p> <p>Approach:</p> <ol> <li>Full Audit: Tag everything with categories</li> <li>Aggressive Split: Move all Cat 3, 4, 5, 6 content out</li> <li>Keep only Cat 1 (Identity) and Cat 2 (Map) in CLAUDE.md</li> <li>Add Discovery Anchors for everything moved</li> </ol> <p>Priority Order:</p> <ol> <li>Move Commands first (biggest token savings, easiest)</li> <li>Move Patterns to Skills (enables reuse)</li> <li>Move Corrections to Rules (enables pattern-matching)</li> <li>Move long docs last</li> </ol>"},{"location":"06-migration-guide/#scenario-4-team-with-conflicting-instructions","title":"Scenario 4: Team with Conflicting Instructions","text":"<p>Situation: Multiple team members have added conflicting instructions to CLAUDE.md.</p> <p>Approach:</p> <ol> <li>Audit with the team: Tag and discuss each section</li> <li>Resolve conflicts before splitting</li> <li>Use Skills for shared patterns (version-controlled, reviewable)</li> <li>Use Rules for enforced conventions</li> <li>Keep CLAUDE.md as minimal shared context</li> </ol> <p>Process:</p> <ol> <li>Create a branch for migration</li> <li>PR review the split content</li> <li>Team agrees on what goes where</li> <li>Merge and update CLAUDE.md</li> </ol>"},{"location":"06-migration-guide/#migration-checklist","title":"Migration Checklist","text":""},{"location":"06-migration-guide/#pre-migration","title":"Pre-Migration","text":"<ul> <li>[ ] Backup current CLAUDE.md</li> <li>[ ] Count current token size (rough estimate: lines \u00d7 5)</li> <li>[ ] Decide if full or incremental migration</li> </ul>"},{"location":"06-migration-guide/#during-migration","title":"During Migration","text":"<ul> <li>[ ] Step 1: Audit complete (all sections tagged)</li> <li>[ ] Step 2: Split complete (files created in correct locations)</li> <li>[ ] Step 3: Link complete (Discovery Anchors in place)</li> </ul>"},{"location":"06-migration-guide/#post-migration","title":"Post-Migration","text":"<ul> <li>[ ] CLAUDE.md under 200 tokens</li> <li>[ ] All moved content accessible</li> <li>[ ] Commands work when invoked</li> <li>[ ] Skills recognized by Claude</li> <li>[ ] Rules trigger on correct file patterns</li> <li>[ ] No information lost</li> </ul>"},{"location":"06-migration-guide/#validation","title":"Validation","text":"<ul> <li>[ ] Start new Claude conversation</li> <li>[ ] Verify Claude has project context</li> <li>[ ] Test a command (<code>/test</code> or similar)</li> <li>[ ] Ask Claude about a pattern (should load skill)</li> <li>[ ] Edit a file that should trigger a rule</li> </ul>"},{"location":"06-migration-guide/#quick-reference","title":"Quick Reference","text":"What You Have Where It Goes How to Link Project description Keep in CLAUDE.md N/A Directory map Keep in CLAUDE.md (brief) N/A Run/build/deploy steps <code>.claude/commands/</code> <code>/command-name</code> How-to patterns <code>.claude/skills/</code> Claude auto-loads File conventions <code>.claude/rules/</code> Auto-triggered Corrections <code>.claude/rules/</code> Auto-triggered Long documentation <code>docs/</code> <code>See docs/file.md</code>"},{"location":"06-migration-guide/#summary","title":"Summary","text":"<ol> <li>Audit: Tag every section with its Information Category (1-6)</li> <li>Split: Move content to proper destinations (Commands, Skills, Rules, Docs)</li> <li>Link: Replace moved content with Discovery Anchors</li> </ol> <p>The Goal: A lean CLAUDE.md (~100 tokens) that serves as an index, with detailed content living in the appropriate mechanism for each type of information.</p> <p>Remember: Migrate when the pain exceeds the effort. A working messy CLAUDE.md is better than a broken organized one.</p> <p>Previous: Section 5 - CLAUDE.md Best Practices Next: Section 7 - Configurable Skills</p>"},{"location":"07-configurable-skills/","title":"Section 7: Configurable Skills","text":"<p>EXPERIMENTAL</p> <p>This section describes an advanced pattern for creating skills that adapt to different projects. The pattern is conceptually sound but the concrete implementations (example skills) will be delivered in Epic 3.</p> <p>Current Status: Pattern documented, examples pending.</p>"},{"location":"07-configurable-skills/#the-problem-hardcoded-conventions-kill-reusability","title":"The Problem: Hardcoded Conventions Kill Reusability","text":"<p>Skills are meant to be portable\u2014write once, use everywhere. But in practice, many skills become project-specific because they hardcode local conventions.</p>"},{"location":"07-configurable-skills/#example-a-non-portable-skill","title":"Example: A Non-Portable Skill","text":"<pre><code># Hexagonal Architecture Skill\n\nWhen implementing Hexagonal Architecture:\n\n1. Put domain logic in `src/domain/`\n2. Put ports (interfaces) in `src/domain/ports/`\n3. Put adapters in `src/infrastructure/adapters/`\n4. Put use cases in `src/application/`\n</code></pre> <p>The Problem: These paths work for this project, but the next project might use:</p> <ul> <li><code>core/</code> instead of <code>src/domain/</code></li> <li><code>interfaces/</code> instead of <code>ports/</code></li> <li>A completely different directory structure</li> </ul> <p>If you share this skill, it won't work. You've mixed Category 4 (Universal Pattern) with Category 5 (Project-Specific Conventions).</p>"},{"location":"07-configurable-skills/#the-solution-separate-universal-how-from-local-where","title":"The Solution: Separate \"Universal How\" from \"Local Where\"","text":"<p>Configurable skills solve this by separating the pattern from the configuration.</p>"},{"location":"07-configurable-skills/#the-pattern-universal","title":"The Pattern (Universal)","text":"<pre><code># Hexagonal Architecture Skill\n\nWhen implementing Hexagonal Architecture:\n\n1. Domain logic goes in the **domain directory**\n2. Port interfaces go in the **ports directory**\n3. Adapter implementations go in the **adapters directory**\n4. Use case orchestration goes in the **application directory**\n</code></pre>"},{"location":"07-configurable-skills/#the-configuration-project-specific","title":"The Configuration (Project-Specific)","text":"<pre><code># Configuration\ndomain_dir: src/domain\nports_dir: src/domain/ports\nadapters_dir: src/infrastructure/adapters\napplication_dir: src/application\n</code></pre>"},{"location":"07-configurable-skills/#the-result","title":"The Result","text":"<p>The skill reads its configuration and applies the pattern using this project's conventions. The same skill works in any project\u2014just change the configuration.</p>"},{"location":"07-configurable-skills/#why-configure-the-precision-reusability-breakthrough","title":"Why Configure? The Precision-Reusability Breakthrough","text":"<p>Configuration solves a fundamental dilemma in AI memory:</p> Without Configuration With Configuration Reusable skills are vague Pattern is reusable AND precise Precise skills are project-bound Configuration is project-specific You must choose one You get both"},{"location":"07-configurable-skills/#the-same-skill-two-projects","title":"The Same Skill, Two Projects","text":"<p>Project A (E-commerce):</p> <pre><code>paths:\n  domain_dir: src/core/domain\n  application_dir: src/core/use-cases\n</code></pre> <p>Project B (Healthcare API):</p> <pre><code>paths:\n  domain_dir: lib/domain\n  application_dir: lib/services\n</code></pre> <p>Same Hexagonal Architecture skill, different structures. The skill teaches how to implement the pattern; the configuration says where in this project.</p>"},{"location":"07-configurable-skills/#benefits-of-configurable-skills","title":"Benefits of Configurable Skills","text":""},{"location":"07-configurable-skills/#1-true-portability","title":"1. True Portability","text":"<p>Write the skill once, configure per project. No more copying and editing. Portability is stack-scoped: a well-crafted skill becomes a reusable asset across all projects in the same technology stack (e.g., all React projects, all Python projects).</p>"},{"location":"07-configurable-skills/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<ul> <li>The skill author focuses on the pattern (the \"how\")</li> <li>The skill user provides the configuration (the \"where\")</li> </ul>"},{"location":"07-configurable-skills/#3-team-consistency","title":"3. Team Consistency","text":"<p>Everyone uses the same skill with the same configuration. No drift between team members.</p>"},{"location":"07-configurable-skills/#4-easier-maintenance","title":"4. Easier Maintenance","text":"<p>Update the skill in one place, all projects benefit. Configuration stays local.</p>"},{"location":"07-configurable-skills/#5-self-documenting","title":"5. Self-Documenting","text":"<p>The configuration block explicitly declares what the skill needs from the project.</p>"},{"location":"07-configurable-skills/#configuration-schema-format","title":"Configuration Schema Format","text":""},{"location":"07-configurable-skills/#basic-structure","title":"Basic Structure","text":"<p>A configurable skill has a <code># Configuration</code> section with a YAML block:</p> <pre><code># Skill Name\n\n## Purpose\n\nWhat this skill does.\n\n## Configuration\n\n```yaml\n# Required\ndomain_dir: src/domain # Where domain logic lives\nports_dir: src/domain/ports # Where port interfaces live\n\n# Optional (with defaults)\nadapters_dir: src/infrastructure # Where adapters live (default: src/adapters)\nuse_barrel_files: true # Whether to use index.ts exports (default: true)\n```\n</code></pre>"},{"location":"07-configurable-skills/#instructions","title":"Instructions","text":"<p>[Instructions that reference config values like \"the domain directory\"]</p> <pre><code>### Schema Elements\n\n| Element | Description | Example |\n|---------|-------------|---------|\n| **Key** | Configuration variable name | `domain_dir` |\n| **Value** | Project-specific value | `src/domain` |\n| **Comment** | Description/purpose | `# Where domain logic lives` |\n| **Default** | Fallback if not specified | `(default: src/adapters)` |\n\n### Required vs. Optional\n\n```yaml\n# Required - skill cannot function without these\ndomain_dir: ???                   # REQUIRED: Where domain logic lives\nports_dir: ???                    # REQUIRED: Where port interfaces live\n\n# Optional - skill has sensible defaults\nfile_extension: .ts               # Optional (default: .ts)\nuse_barrel_files: true            # Optional (default: true)\n```\n</code></pre> <p>Skills should:</p> <ul> <li>Fail clearly if required config is missing</li> <li>Use sensible defaults for optional config</li> <li>Document what each config key controls</li> </ul>"},{"location":"07-configurable-skills/#type-hints","title":"Type Hints","text":"<p>While not enforced, document expected types in comments:</p> <pre><code># Paths\ndomain_dir: src/domain # string: directory path\nports_dir: src/domain/ports # string: directory path\n\n# Booleans\nuse_barrel_files: true # boolean: true/false\nstrict_mode: false # boolean: true/false\n\n# Lists\nallowed_extensions: # list: file extensions\n  - .ts\n  - .tsx\n\n# Numbers\nmax_file_lines: 500 # number: maximum lines per file\n</code></pre>"},{"location":"07-configurable-skills/#self-initialization-patterns","title":"Self-Initialization Patterns","text":"<p>Configurable skills can get their configuration in three ways:</p>"},{"location":"07-configurable-skills/#pattern-1-scan-mode","title":"Pattern 1: Scan Mode","text":"<p>The skill examines the codebase to infer configuration values.</p> <p>How it works:</p> <ol> <li>Skill is invoked without configuration</li> <li>Skill scans project structure (package.json, directory layout, etc.)</li> <li>Skill infers configuration values</li> <li>Skill proceeds with inferred values</li> </ol> <p>Best for:</p> <ul> <li>Projects with standard structures (Next.js, Rails, etc.)</li> <li>Configuration that can be reliably detected</li> <li>Reducing friction for first-time use</li> </ul> <p>Example Scan Logic:</p> <pre><code>## Self-Initialization\n\nIf configuration is not provided, this skill will attempt to detect values:\n\n1. Check for `src/domain/` \u2192 set `domain_dir: src/domain`\n2. Check for `core/` \u2192 set `domain_dir: core`\n3. Check for `app/domain/` \u2192 set `domain_dir: app/domain`\n4. If none found \u2192 prompt user\n</code></pre>"},{"location":"07-configurable-skills/#pattern-2-prompt-mode","title":"Pattern 2: Prompt Mode","text":"<p>The skill asks the user for configuration on first use.</p> <p>How it works:</p> <ol> <li>Skill is invoked without configuration</li> <li>Skill prompts user for each required value</li> <li>Skill can write configuration to the skill file for future use</li> <li>Skill proceeds with provided values</li> </ol> <p>Best for:</p> <ul> <li>Non-standard project structures</li> <li>Configuration that can't be reliably detected</li> <li>Ensuring explicit user intent</li> </ul> <p>Example Prompt:</p> <pre><code>## Self-Initialization\n\nThis skill requires configuration. Please provide:\n\n1. **Domain directory**: Where should domain logic go?\n   Example: `src/domain`, `core`, `lib/domain`\n\n2. **Ports directory**: Where should port interfaces go?\n   Example: `src/domain/ports`, `core/interfaces`\n\n3. **Adapters directory**: Where should adapters go?\n   Example: `src/infrastructure`, `lib/adapters`\n</code></pre>"},{"location":"07-configurable-skills/#pattern-3-hybrid-scan-confirm","title":"Pattern 3: Hybrid (Scan + Confirm)","text":"<p>The skill scans, then confirms with the user.</p> <p>How it works:</p> <ol> <li>Skill scans project structure</li> <li>Skill presents inferred values to user</li> <li>User confirms or corrects</li> <li>Skill proceeds with confirmed values</li> </ol> <p>Best for:</p> <ul> <li>Balancing automation with user control</li> <li>Catching misdetections</li> <li>Building user confidence</li> </ul> <p>Example Hybrid:</p> <pre><code>## Self-Initialization\n\nI detected the following structure:\n\n- Domain directory: `src/domain` \u2713\n- Ports directory: `src/domain/ports` \u2713\n- Adapters directory: `src/infrastructure` \u2713\n\nDoes this look correct? If not, please provide corrections.\n</code></pre>"},{"location":"07-configurable-skills/#when-to-use-each-pattern","title":"When to Use Each Pattern","text":"Pattern Use When Scan Standard frameworks, high confidence detection Prompt Unusual structures, critical configuration Hybrid Balance of convenience and control"},{"location":"07-configurable-skills/#structure-template","title":"Structure Template","text":""},{"location":"07-configurable-skills/#skillmd-template","title":"SKILL.md Template","text":"<pre><code>---\nname: {skill-name}\ndescription: |\n  {What this skill does}.\n  Use when {triggers/scenarios}.\n  Configurable: requires project-specific paths.\nallowed-tools: Read, Grep, Glob\n---\n\n# {Skill Name}\n\n&gt; **Configurable Skill**: This skill requires project-specific configuration.\n&gt; See Configuration section below.\n\n## Purpose\n\n{Brief description of what this skill accomplishes.}\n\n## Configuration\n\n```yaml\n# Required\n{key1}: {example_value}          # {description}\n{key2}: {example_value}          # {description}\n\n# Optional\n{key3}: {default_value}          # {description} (default: {default})\n```\n\n## Self-Initialization\n\n{Describe how the skill gets its configuration if not provided.}\n\nOption 1: Scan\n\n- Look for {pattern} \u2192 set {key1}\n- Look for {pattern} \u2192 set {key2}\n\nOption 2: Prompt\n\n- Ask user for {key1}: \"{question}\"\n- Ask user for {key2}: \"{question}\"\n\n## Instructions\n\n### Step 1: {First Step}\n\n{Instructions referencing config like \"the domain directory\" or \"configured ports path\"}\n\n### Step 2: {Second Step}\n\n{More instructions...}\n\n## Examples\n\n### Example 1: {Scenario}\n\n{Show the skill applied with sample configuration}\n\n## Validation\n\n{How to verify the skill was applied correctly}\n</code></pre>"},{"location":"07-configurable-skills/#readmemd-companion-template","title":"README.md Companion Template","text":"<p>For skills distributed as packages or shared across teams:</p> <pre><code># {Skill Name}\n\n{Brief description}\n\n## Installation\n\nCopy the `{skill-name}/` folder to your project's `.claude/skills/` directory.\n\n## Configuration\n\nBefore first use, configure the skill by editing `SKILL.md`:\n\n```yaml\n# Configuration\n{ key1 }: { your_value } # {what this controls}\n{ key2 }: { your_value } # {what this controls}\n```\n\n## Usage\n\n{How to invoke the skill}\n\n## Configuration Reference\n\n| Key      | Required | Default     | Description   |\n| -------- | -------- | ----------- | ------------- |\n| `{key1}` | Yes      | -           | {description} |\n| `{key2}` | Yes      | -           | {description} |\n| `{key3}` | No       | `{default}` | {description} |\n\n## Examples\n\n{Show the skill in action with different configurations}\n</code></pre>"},{"location":"07-configurable-skills/#example-hexagonal-architecture-skill","title":"Example: Hexagonal Architecture Skill","text":"<p>Here's what a complete configurable skill looks like:</p> <pre><code>---\nname: hexagonal-architecture\ndescription: |\n  Implements Hexagonal Architecture (Ports and Adapters) pattern.\n  Use when creating domain logic, defining ports, or implementing adapters.\n  Configurable: requires project-specific directory paths.\nallowed-tools: Read, Write, Grep, Glob\n---\n\n# Hexagonal Architecture\n\n&gt; **Configurable Skill**: Edit the Configuration section for your project structure.\n\n## Purpose\n\nGuides implementation of Hexagonal Architecture, ensuring proper separation between\ndomain logic (inside) and infrastructure (outside).\n\n## Configuration\n\n```yaml\n# Required - specify your project's directory structure\npaths:\n  domain_dir: src/domain              # Where domain entities and logic live\n  ports_dir: src/domain/ports         # Where port interfaces are defined\n  adapters_dir: src/infrastructure    # Where adapter implementations live\n  application_dir: src/application    # Where use cases/services live\n\n# Optional\nnaming:\n  file_case: kebab-case               # kebab-case, PascalCase, or camelCase\n  use_barrel_files: true              # Create index.ts exports (default: true)\n\n# Architectural decisions (embedded markdown for complex guidance)\ndecisions:\n  repository_placement: |\n    ## Where to Place Repositories\n\n    **Decision:** Repositories can be use-case-specific or shared.\n\n    | Condition | Location | Rationale |\n    |-----------|----------|-----------|\n    | Used by 1 use case | `{application_dir}/{use-case}/repositories/` | Keep cohesion |\n    | Used by 2+ use cases | `{domain_dir}/repositories/` | Avoid duplication |\n\n    **Example:** `OrderRepository` used by CreateOrder and CancelOrder \u2192 shared.\n```\n\n&gt; **Note on `decisions:`** The `decisions:` key holds embedded markdown using YAML multiline\n&gt; strings (`|`). This keeps all configuration in one block while allowing rich decision\n&gt; documentation that Claude can render and apply.\n\n## Self-Initialization\n\nIf configuration is empty, I will:\n\n1. **Scan** for common patterns:\n   - `src/domain/` \u2192 domain_dir\n   - `core/domain/` \u2192 domain_dir\n   - `lib/domain/` \u2192 domain_dir\n\n2. **Prompt** if not found:\n   - \"Where should domain logic live? (e.g., src/domain)\"\n\n## Instructions\n\n### Creating Domain Entities\n\n1. Create entity in the **domain directory** (`domain_dir`)\n2. Entity should have no external dependencies\n3. Export from barrel file if `use_barrel_files` is enabled\n\n### Defining Ports\n\n1. Create interface in the **ports directory** (`ports_dir`)\n2. Ports define what the domain needs from the outside world\n3. Name convention: `I{Noun}Repository`, `I{Noun}Service`\n\n### Implementing Adapters\n\n1. Create implementation in the **adapters directory** (`adapters_dir`)\n2. Adapter implements a port interface\n3. Contains all infrastructure-specific code (database, HTTP, etc.)\n\n### Creating Use Cases\n\n1. Create use case in the **application directory** (`application_dir`)\n2. Use case orchestrates domain entities via ports\n3. Inject adapters through constructor\n</code></pre>"},{"location":"07-configurable-skills/#use-cases-for-configurable-skills","title":"Use Cases for Configurable Skills","text":""},{"location":"07-configurable-skills/#architecture-patterns","title":"Architecture Patterns","text":"<ul> <li>Hexagonal Architecture (ports, adapters, domain)</li> <li>Clean Architecture (entities, use cases, interfaces)</li> <li>MVC variants (models, views, controllers)</li> </ul>"},{"location":"07-configurable-skills/#testing-conventions","title":"Testing Conventions","text":"<ul> <li>Test file locations and naming</li> <li>Fixture patterns</li> <li>Mock/stub conventions</li> </ul>"},{"location":"07-configurable-skills/#coding-standards","title":"Coding Standards","text":"<ul> <li>File naming patterns</li> <li>Export conventions</li> <li>Error handling patterns</li> </ul>"},{"location":"07-configurable-skills/#workflow-automation","title":"Workflow Automation","text":"<ul> <li>PR templates with project-specific sections</li> <li>Deployment scripts with environment paths</li> <li>Build configurations</li> </ul>"},{"location":"07-configurable-skills/#invocation-reliability","title":"Invocation Reliability","text":""},{"location":"07-configurable-skills/#the-problem-silent-invocation-failure","title":"The Problem: Silent Invocation Failure","text":"<p>When a skill's invocation is set to automatic (the default), Claude decides whether to invoke it based on the <code>description</code> frontmatter and conversation context. This decision is probabilistic\u2014a skill that fires reliably in one session may not fire in another. Worse, failures are silent: Claude simply proceeds without the skill, and you may not notice the difference until you see lower-quality output.</p>"},{"location":"07-configurable-skills/#techniques-to-improve-reliability","title":"Techniques to Improve Reliability","text":""},{"location":"07-configurable-skills/#1-add-explicit-directives-in-claudemd","title":"1. Add Explicit Directives in CLAUDE.md","text":"<p>Tell Claude when to use specific skills:</p> <pre><code># In CLAUDE.md\n## Skill Directives\n- Always use `/code-review` when reviewing pull requests\n- Use `/error-handling` when implementing try/catch patterns\n- Use `/hexagonal-architecture` when creating domain or adapter code\n</code></pre> <p>This trades a small amount of context economy for significantly more reliable invocation.</p>"},{"location":"07-configurable-skills/#2-use-the-skill-tool-explicitly","title":"2. Use the Skill Tool Explicitly","text":"<p>In prompts to Claude, reference the Skill tool directly:</p> <pre><code>Use the Skill tool to invoke the `code-review` skill, then review this PR.\n</code></pre> <p>This removes ambiguity and forces the invocation.</p>"},{"location":"07-configurable-skills/#3-use-fully-qualified-skill-names","title":"3. Use Fully Qualified Skill Names","text":"<p>When a project or skill pack uses namespaced skills, reference the full qualified name:</p> <pre><code>Use the `/my-project:error-handling` skill.\n</code></pre>"},{"location":"07-configurable-skills/#4-write-precise-description-frontmatter","title":"4. Write Precise <code>description</code> Frontmatter","text":"<p>The <code>description</code> field is how Claude decides whether to auto-invoke a skill. Vague descriptions lead to unreliable matching. Be specific about triggers:</p> <pre><code># Bad \u2014 vague, Claude may not match this to relevant situations\ndescription: \"Helps with code quality\"\n\n# Good \u2014 specific triggers Claude can match against\ndescription: |\n  Reviews code for security vulnerabilities, performance issues, and style violations.\n  Use when reviewing pull requests, auditing code, or when the user asks about\n  code quality, best practices, or security concerns.\n</code></pre>"},{"location":"07-configurable-skills/#5-preload-skills-into-custom-sub-agents","title":"5. Preload Skills into Custom Sub-agents","text":"<p>Custom sub-agents (<code>.claude/agents/</code>) support a <code>skills:</code> frontmatter field that injects the full skill content into the agent's context at startup:</p> <pre><code>---\nskills:\n  - error-handling\n  - code-review\n---\n</code></pre> <p>This guarantees the sub-agent has access to the skill content\u2014no probabilistic invocation needed. Note that ad-hoc Task tool sub-agents (Explore, Plan, general-purpose) do not support this mechanism; for those, pass skill content directly in the prompt.</p>"},{"location":"07-configurable-skills/#limitations-and-future-work","title":"Limitations and Future Work","text":""},{"location":"07-configurable-skills/#current-limitations","title":"Current Limitations","text":"<ol> <li>No runtime enforcement: Configuration is documentation, not code</li> <li>Manual configuration: Users must edit the YAML block</li> <li>No validation: Skills can't verify configuration is correct</li> </ol>"},{"location":"07-configurable-skills/#future-improvements-epic-3","title":"Future Improvements (Epic 3)","text":"<ol> <li>Example implementations: Concrete skills demonstrating the pattern</li> <li>Self-initialization logic: Built-in scan/prompt patterns</li> <li>Configuration validation: Check paths exist, types are correct</li> </ol>"},{"location":"07-configurable-skills/#summary","title":"Summary","text":"<p>Configurable skills solve the portability problem by separating:</p> <ul> <li>The Pattern (universal knowledge) in skill instructions</li> <li>The Configuration (project-specific values) in a YAML block</li> </ul> <p>Key Concepts:</p> <ol> <li>Configuration Schema: YAML block with required/optional keys</li> <li>Self-Initialization: Scan, prompt, or hybrid to get values</li> <li>Reference by Name: Instructions use \"the domain directory\" not <code>src/domain</code></li> </ol> <p>This pattern enables true skill reusability\u2014write once, configure per project.</p> <p>Previous: Section 6 - Migration Guide Next: Worked Examples</p>"},{"location":"examples/worked-examples/","title":"Worked Examples","text":"<p>This document contains 6 worked examples demonstrating the TrigMem decision process. Each example walks through Phase 1 (Triage) and Phase 2 (Refinement) to arrive at the correct storage location.</p> <p>How to Use These Examples:</p> <ol> <li>Read the scenario</li> <li>Try to decide the destination yourself using the Two-Phase Decision Guide</li> <li>Expand the solution to check your answer</li> <li>Review the rationale to understand the reasoning</li> </ol>"},{"location":"examples/worked-examples/#example-1-project-tech-stack","title":"Example 1: Project Tech Stack","text":""},{"location":"examples/worked-examples/#scenario","title":"Scenario","text":"<p>\"We use PostgreSQL with Prisma as our ORM. The database runs in Docker locally.\"</p> <p>Try it first: Where does this information go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? No. This is information, not an action.</p> <p>Q2: Is this universal how-to knowledge portable across projects? No. This is about this specific project's tech stack, not a general pattern.</p> <p>Q3: Does this need context isolation or parallel execution? No. This is just context information.</p> <p>Q4: Is this always-needed project context or corrections? Yes! This is project identity\u2014Claude needs to know this in every conversation.</p> <p>\u2192 Destination: CLAUDE.md</p>"},{"location":"examples/worked-examples/#phase-2-refinement","title":"Phase 2: Refinement","text":"<p>Is it project identity or structure? Project identity (what technologies we use).</p> <p>Is it too long for CLAUDE.md? No, it's one line.</p>"},{"location":"examples/worked-examples/#final-decision","title":"Final Decision","text":"<p>\u2192 CLAUDE.md</p> <pre><code># MyProject\nPostgreSQL + Prisma. Docker for local database.\n</code></pre>"},{"location":"examples/worked-examples/#rationale","title":"Rationale","text":"<p>This is Category 1 (Project Identity)\u2014essential context that Claude needs in every conversation to understand the project. It's brief enough to include directly in CLAUDE.md without violating token economy principles.</p>"},{"location":"examples/worked-examples/#example-2-deployment-workflow","title":"Example 2: Deployment Workflow","text":""},{"location":"examples/worked-examples/#scenario_1","title":"Scenario","text":"<p>\"To deploy to staging: run tests, build the Docker image, push to registry, and trigger the Kubernetes deployment.\"</p> <p>Try it first: Where does this information go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage_1","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? Yes! This is a multi-step workflow that deploys code\u2014definitely has side effects.</p> <p>\u2192 Destination: Command</p>"},{"location":"examples/worked-examples/#phase-2-refinement_1","title":"Phase 2: Refinement","text":"<p>Is it a simple, single action? No, it's a multi-step workflow with prerequisites.</p> <p>Does it need arguments? Possibly\u2014environment (staging vs production) could be an argument.</p> <p>Should Claude NEVER auto-invoke this? Correct. Commands are user-only by default. This is appropriate for deployment.</p>"},{"location":"examples/worked-examples/#final-decision_1","title":"Final Decision","text":"<p>\u2192 Command at <code>.claude/commands/deploy.md</code></p> <pre><code># Deploy\n\nDeploy the application to an environment.\n\n## Usage\n/deploy [environment]\n\n## Environments\n- staging (default)\n- production\n\n## Steps\n\n1. Run tests\n   ```bash\n   pnpm test\n   ```\n\n2. Build Docker image\n   ```bash\n   docker build -t myapp:latest .\n   ```\n\n3. Push to registry\n   ```bash\n   docker push registry.example.com/myapp:latest\n   ```\n\n4. Trigger Kubernetes deployment\n   ```bash\n   kubectl rollout restart deployment/myapp -n $ENVIRONMENT\n   ```\n\n## Pre-flight Checks\n- [ ] All tests pass\n- [ ] On main branch (for production)\n- [ ] CHANGELOG updated\n</code></pre>"},{"location":"examples/worked-examples/#rationale_1","title":"Rationale","text":"<p>This is Category 3 (Operational Commands)\u2014a workflow with significant side effects that the user should explicitly trigger. Commands are the right mechanism because: - User controls when deployment happens - Side effects (deploying to servers) are significant - Multi-step process benefits from documented procedure</p>"},{"location":"examples/worked-examples/#example-3-repository-pattern-implementation","title":"Example 3: Repository Pattern Implementation","text":""},{"location":"examples/worked-examples/#scenario_2","title":"Scenario","text":"<p>\"How to implement the Repository Pattern: repositories abstract data access, provide collection-like interfaces for domain objects, and hide persistence details from the domain layer.\"</p> <p>Try it first: Where does this information go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage_2","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? No. This is knowledge/guidance, not an action.</p> <p>Q2: Is this universal how-to knowledge portable across projects? Yes! The Repository Pattern is a universal design pattern that applies to any project using similar architecture.</p> <p>\u2192 Destination: Skill</p>"},{"location":"examples/worked-examples/#phase-2-refinement_2","title":"Phase 2: Refinement","text":"<p>Is it truly portable? Yes. The Repository Pattern concept applies to any project using domain-driven design, regardless of language or framework.</p> <p>Should Claude auto-invoke it? Yes, Claude should use this knowledge when the user is working on data access or domain logic. Default skill behavior (both user and Claude can invoke) is appropriate.</p> <p>Is it configurable? Could be\u2014repository locations vary by project. But the core pattern is universal.</p>"},{"location":"examples/worked-examples/#final-decision_2","title":"Final Decision","text":"<p>\u2192 Skill at <code>.claude/skills/repository-pattern/SKILL.md</code></p> <pre><code>---\nname: repository-pattern\ndescription: |\n  Implements the Repository Pattern for data access abstraction.\n  Use when creating repositories, working with domain entities,\n  or designing data access layers.\nallowed-tools: Read, Write, Grep, Glob\n---\n\n# Repository Pattern\n\n## Purpose\nGuide implementation of the Repository Pattern to abstract data access\nfrom domain logic.\n\n## Core Principles\n\n1. **Abstract Data Access**: Repositories provide a collection-like\n   interface for domain objects\n\n2. **Hide Persistence**: Domain layer shouldn't know about databases,\n   files, or APIs\n\n3. **Single Responsibility**: Each repository handles one aggregate root\n\n## Implementation Steps\n\n### Step 1: Define Repository Interface\n```typescript\ninterface UserRepository {\n  findById(id: string): Promise&lt;User | null&gt;;\n  findByEmail(email: string): Promise&lt;User | null&gt;;\n  save(user: User): Promise&lt;void&gt;;\n  delete(user: User): Promise&lt;void&gt;;\n}\n```\n\n### Step 2: Implement Repository\n[... implementation details ...]\n</code></pre>"},{"location":"examples/worked-examples/#rationale_2","title":"Rationale","text":"<p>This is Category 4 (Reusable Patterns)\u2014universal knowledge that applies across projects. Skills are ideal because: - Loaded on-demand (no token cost when not needed) - Portable (works in any project using this pattern) - Auto-invokable (Claude uses it when relevant) - Composable (can be combined with other patterns)</p>"},{"location":"examples/worked-examples/#example-4-large-refactoring-task","title":"Example 4: Large Refactoring Task","text":""},{"location":"examples/worked-examples/#scenario_3","title":"Scenario","text":"<p>\"Refactor all 15 API handlers in the <code>src/api/</code> folder to use the new error handling pattern. Each handler needs updated try/catch blocks and standardized error responses.\"</p> <p>Try it first: Where does this information go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage_3","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? Yes, but this is more about execution than a stored workflow.</p> <p>Q2: Is this universal how-to knowledge portable across projects? No. This is about refactoring this specific codebase.</p> <p>Q3: Does this need context isolation or parallel execution? Yes! This is a large, multi-file refactoring task. Benefits from: - Isolated context (don't clutter main conversation) - Potentially parallel work (multiple handlers can be updated independently) - Focused execution (single task, clear completion criteria)</p> <p>\u2192 Destination: Sub-agent</p>"},{"location":"examples/worked-examples/#phase-2-refinement_3","title":"Phase 2: Refinement","text":"<p>Why do you need isolation? - Large task (15 files) - Don't want intermediate steps cluttering the main conversation - Clear handoff: \"refactoring complete\" with summary of changes</p> <p>Does the agent need special context? Yes\u2014the error handling pattern. Could reference an error-handling skill.</p>"},{"location":"examples/worked-examples/#final-decision_3","title":"Final Decision","text":"<p>\u2192 Sub-agent (spawned for this task, not a persistent file)</p> <p>The user would invoke this as a task, not store it permanently:</p> <pre><code>\"Use a sub-agent to refactor all API handlers in src/api/ to use the\nnew error handling pattern. The pattern is documented in\n.claude/skills/error-handling/SKILL.md.\"\n</code></pre> <p>Note: In this ad-hoc Task tool invocation, the parent context has access to CLAUDE.md and the skill registry. It reads the skill file and passes its content into the sub-agent's prompt. The sub-agent itself does not have direct access to the skill registry\u2014it only sees what the parent explicitly provides.</p> <p>Or if this is a recurring task, create an agent definition:</p> <p><code>.claude/agents/refactor-agent.md</code> <pre><code># Refactoring Agent\n\nYou are a refactoring specialist focused on systematic code updates.\n\n## Context\n- Reference the error-handling skill for the target pattern\n- Work through files methodically\n- Report changes made in each file\n\n## Approach\n1. List all files matching the pattern\n2. For each file:\n   - Read current implementation\n   - Apply the new pattern\n   - Verify changes compile\n3. Summarize all changes\n</code></pre></p> <p>\u26a0\ufe0f Sub-agents Don't Auto-Inherit Skills</p> <p>The agent definition above says \"Reference the error-handling skill,\" but sub-agents do not automatically inherit the parent conversation's skill registry.</p> <p>For custom sub-agents (<code>.claude/agents/</code>): Use the <code>skills:</code> frontmatter field to preload the skill into the agent's context:</p> <pre><code>---\nskills:\n  - error-handling\n---\n\n# Refactoring Agent\n...\n</code></pre> <p>For ad-hoc Task tool prompts: The parent context (which does have skill access) should read the skill file and pass its content directly in the prompt. The sub-agent itself has no access to the skill registry.</p>"},{"location":"examples/worked-examples/#rationale_3","title":"Rationale","text":"<p>This is a complex, multi-file task that benefits from context isolation: - Main conversation stays clean - Agent can work through files systematically - Clear completion handoff with summary - Could potentially parallelize across multiple agents</p> <p>This isn't a \"storage\" decision per se\u2014it's recognizing that sub-agents are the right execution mechanism for this type of work.</p>"},{"location":"examples/worked-examples/#example-5-coding-style-preferences-edge-case","title":"Example 5: Coding Style Preferences (Edge Case)","text":""},{"location":"examples/worked-examples/#scenario_4","title":"Scenario","text":"<p>\"We prefer functional components over class components. Use arrow functions for handlers. Destructure props in the function signature. Keep components under 200 lines.\"</p> <p>Try it first: This one is tricky\u2014where does this information go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage_4","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? No. These are preferences/guidelines.</p> <p>Q2: Is this universal how-to knowledge portable across projects? Partially. \"Prefer functional components\" is universal React knowledge, but \"keep under 200 lines\" is a project-specific convention.</p> <p>Q3: Does this need context isolation or parallel execution? No.</p> <p>Q4: Is this always-needed project context or corrections? Depends on interpretation...</p> <p>\u2192 This is ambiguous\u2014could go multiple places!</p>"},{"location":"examples/worked-examples/#the-ambiguity","title":"The Ambiguity","text":"<p>This content mixes multiple categories: - \"Prefer functional components\" \u2192 Could be Category 4 (Reusable Patterns) \u2014 universal React knowledge - \"Keep under 200 lines\" \u2192 Could be Category 5 (Architectural Guidance) or Category 6 (Iterative Corrections) - All of it could go in Rules triggered by <code>.tsx</code> files</p>"},{"location":"examples/worked-examples/#phase-2-analyze-each-piece","title":"Phase 2: Analyze Each Piece","text":"Preference Category Best Destination Functional over class Universal React knowledge Could be Skill or Rule Arrow functions for handlers Convention Rule (triggered by React files) Destructure props Convention Rule (triggered by React files) Under 200 lines Project convention Rule (triggered by all files)"},{"location":"examples/worked-examples/#final-decision_4","title":"Final Decision","text":"<p>\u2192 Rules at <code>.claude/rules/react-components.md</code></p> <pre><code>---\nglobs: [\"*.tsx\", \"*.jsx\"]\n---\n\n# React Component Guidelines\n\nWhen working with React components:\n\n- Use functional components (not class components)\n- Use arrow functions for event handlers\n- Destructure props in the function signature\n- Keep components under 200 lines\u2014split if larger\n</code></pre>"},{"location":"examples/worked-examples/#why-rules","title":"Why Rules?","text":"<ol> <li>Pattern-triggered: These guidelines apply when editing React files</li> <li>Contextual: Loaded only when relevant (editing <code>.tsx</code> files)</li> <li>Project-specific: While some are universal React practices, they're codified    as this project's conventions</li> </ol>"},{"location":"examples/worked-examples/#alternative-split-it","title":"Alternative: Split It","text":"<p>If some guidelines are truly universal (and you want to share them): - Universal patterns \u2192 Skill (e.g., <code>react-best-practices</code>) - Project conventions \u2192 Rules (e.g., <code>react-components.md</code>)</p> <p>Example Skill at <code>.claude/skills/react-best-practices/SKILL.md</code>:</p> <pre><code>---\nname: react-best-practices\ndescription: |\n  Universal React component patterns and best practices.\n  Use when writing or reviewing React components.\nallowed-tools: Read, Write, Grep, Glob\n---\n\n# React Best Practices\n\n## Functional Components\n\nPrefer functional components over class components:\n- Simpler to read and test\n- Better performance with React hooks\n- Easier to share logic between components\n\n## Event Handlers\n\nUse arrow functions for event handlers:\n```tsx\n// Good\nconst handleClick = () =&gt; { ... }\n\n// Avoid\nfunction handleClick() { ... }\n```\n\n## Props Destructuring\n\nDestructure props in the function signature:\n```tsx\n// Good\nconst Button = ({ label, onClick, disabled }: ButtonProps) =&gt; { ... }\n\n// Avoid\nconst Button = (props: ButtonProps) =&gt; { ... }\n```\n</code></pre> <p>Example Rules at <code>.claude/rules/react-components.md</code> (referencing the skill):</p> <pre><code>---\nglobs: [\"*.tsx\", \"*.jsx\"]\n---\n\n# React Component Conventions\n\nFor universal React patterns, see the `react-best-practices` skill.\n\nProject-specific conventions for this codebase:\n\n- Keep components under 200 lines\u2014split into smaller components if larger\n- Place shared components in `src/components/shared/`\n- Use the naming convention `ComponentName.tsx` (PascalCase)\n</code></pre>"},{"location":"examples/worked-examples/#rationale_4","title":"Rationale","text":"<p>This edge case shows that: 1. Content can mix categories 2. Rules are good for file-specific conventions 3. When in doubt, ask: \"When should this load?\" (always \u2192 CLAUDE.md, file pattern \u2192 Rules)</p>"},{"location":"examples/worked-examples/#example-6-testing-fixtures-edge-case","title":"Example 6: Testing Fixtures (Edge Case)","text":""},{"location":"examples/worked-examples/#scenario_5","title":"Scenario","text":"<p>\"In test files, always use fixtures from <code>tests/fixtures/</code>. Never create inline test data. Import fixtures at the top of the test file.\"</p> <p>Try it first: Another tricky one\u2014where does this go?</p> Click to see solution"},{"location":"examples/worked-examples/#phase-1-triage_5","title":"Phase 1: Triage","text":"<p>Q1: Is this a user-triggered action with side effects? No. This is a testing convention.</p> <p>Q2: Is this universal how-to knowledge portable across projects? No. The fixture location (<code>tests/fixtures/</code>) is project-specific.</p> <p>Q3: Does this need context isolation or parallel execution? No.</p> <p>Q4: Is this always-needed project context or corrections? Yes, but only when writing tests.</p> <p>\u2192 Destination: Rules (pattern-triggered)</p>"},{"location":"examples/worked-examples/#phase-2-refinement_4","title":"Phase 2: Refinement","text":"<p>Is it tied to specific file patterns? Yes! This applies when editing test files (<code>.test.ts</code>, <code>.spec.ts</code>, etc.)</p> <p>Is it a correction for repeated mistakes? Partially\u2014\"never create inline test data\" suggests Claude has done this wrong before.</p>"},{"location":"examples/worked-examples/#final-decision_5","title":"Final Decision","text":"<p>\u2192 Rules at <code>.claude/rules/testing.md</code></p> <pre><code>---\nglobs: [\"*.test.ts\", \"*.test.tsx\", \"*.spec.ts\", \"*.spec.tsx\"]\n---\n\n# Testing Conventions\n\nWhen writing or modifying tests:\n\n- Use fixtures from `tests/fixtures/` for test data\n- Never create inline test data objects\n- Import fixtures at the top of the test file\n\nExample:\n```typescript\nimport { mockUser, mockOrder } from 'tests/fixtures/users';\n\ndescribe('OrderService', () =&gt; {\n  it('should process order', () =&gt; {\n    const result = processOrder(mockUser, mockOrder);\n    // ...\n  });\n});\n```\n</code></pre>"},{"location":"examples/worked-examples/#why-not-claudemd","title":"Why Not CLAUDE.md?","text":"<p>While you could put \"we use fixtures\" in CLAUDE.md, it's more effective in Rules because: - Loads only when editing test files (token economy) - Appears at the right moment (contextual) - Can include specific examples</p>"},{"location":"examples/worked-examples/#why-not-a-skill","title":"Why Not a Skill?","text":"<p>The fixture pattern is project-specific (the path <code>tests/fixtures/</code>). A skill would need to be configurable to be portable.</p>"},{"location":"examples/worked-examples/#rationale_5","title":"Rationale","text":"<p>This is Category 6 (Iterative Corrections) combined with Category 5 (Architectural Guidance). Rules are ideal because they trigger automatically when editing test files, ensuring the guidance appears when it's most relevant.</p>"},{"location":"examples/worked-examples/#quick-reference-pattern-matching","title":"Quick Reference: Pattern Matching","text":"If the content is about... Consider... What the project is CLAUDE.md Where things are CLAUDE.md (brief) or Rules How to run/build/deploy Command Universal patterns/methods Skill Project-specific conventions Rules \"Don't do X\" corrections Rules Large multi-file tasks Sub-agent Detailed reference docs External docs + pointer"},{"location":"examples/worked-examples/#self-check-questions","title":"Self-Check Questions","text":"<p>After working through an example, ask yourself:</p> <ol> <li>Did Phase 1 identify the right destination?</li> <li>If Q1 was Yes \u2192 Command</li> <li>If Q2 was Yes \u2192 Skill</li> <li>If Q3 was Yes \u2192 Sub-agent</li> <li> <p>If Q4 was Yes \u2192 CLAUDE.md / Rules</p> </li> <li> <p>Did Phase 2 refine the decision correctly?</p> </li> <li>For CLAUDE.md: Is it brief enough? Use pointer pattern if long.</li> <li>For Commands: Is it user-triggered with side effects?</li> <li>For Skills: Is it truly portable? Consider configurable pattern if not.</li> <li> <p>For Rules: Is it tied to file patterns?</p> </li> <li> <p>What category is this content?</p> </li> <li>Cat 1: Project Identity \u2192 CLAUDE.md</li> <li>Cat 2: Codebase Structure \u2192 CLAUDE.md</li> <li>Cat 3: Operational Commands \u2192 Command</li> <li>Cat 4: Reusable Patterns \u2192 Skill</li> <li>Cat 5: Architectural Guidance \u2192 Rules</li> <li>Cat 6: Iterative Corrections \u2192 Rules</li> </ol> <p>Back to: Two-Phase Decision Guide</p>"}]}